<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SymbolTableReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-javaaaaaaaaaaaaaaa</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">SymbolTableReader.java</span></div><h1>SymbolTableReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;


import static com.amazon.ion.SystemSymbols.IMPORTS;
import static com.amazon.ion.SystemSymbols.IMPORTS_SID;
import static com.amazon.ion.SystemSymbols.ION_SHARED_SYMBOL_TABLE;
import static com.amazon.ion.SystemSymbols.ION_SHARED_SYMBOL_TABLE_SID;
import static com.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE;
import static com.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE_SID;
import static com.amazon.ion.SystemSymbols.MAX_ID;
import static com.amazon.ion.SystemSymbols.MAX_ID_SID;
import static com.amazon.ion.SystemSymbols.NAME;
import static com.amazon.ion.SystemSymbols.NAME_SID;
import static com.amazon.ion.SystemSymbols.SYMBOLS;
import static com.amazon.ion.SystemSymbols.SYMBOLS_SID;
import static com.amazon.ion.SystemSymbols.VERSION;
import static com.amazon.ion.SystemSymbols.VERSION_SID;
import static com.amazon.ion.impl._Private_Utils.newSymbolToken;

import com.amazon.ion.Decimal;
import com.amazon.ion.IntegerSize;
import com.amazon.ion.IonException;
import com.amazon.ion.IonReader;
import com.amazon.ion.IonType;
import com.amazon.ion.SymbolTable;
import com.amazon.ion.SymbolToken;
import com.amazon.ion.Timestamp;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;

/**
 *   This is a reader that traverses a {@link SymbolTable}
 *   and returns the contents as if the table was serialized
 *   in Ion in a standard fashion (in fact this serialization
 *   defines the &quot;standard fashion&quot;).
 *
 *   This does not support open content in symbol tables and
 *   should.  Support for open content will require additional
 *   data be kept in the {@link SymbolTable}, probably as an
 *   IonStruct or an IonReader or binary buffer.
 *
 *   The reader uses the _state member to track its progress
 *   through the members of the outer struct, the import
 *   list and the symbol list.  It used _idx to track its
 *   progress thought the elements of the import list and
 *   the elements of the symbol list.
 *
 *

    These are the states in a local symbol table:

        &lt;S_BOF&gt;
        &lt;S_STRUCT&gt;
        $ion_symbol_table:: {
          &lt;S_IN_STRUCT&gt;
          &lt;S_MAX_ID&gt;
            max_id:3,
          &lt;S_SYMBOL_LIST&gt;
            symbols:[
          &lt;S_IN_SYMBOLS&gt;
          &lt;S_SYMBOL&gt;
              &quot;symbol1&quot;,
          &lt;S_SYMBOL&gt;
              &quot;symbol2&quot;,
          &lt;S_SYMBOL&gt;
              &quot;symbol3&quot;
          &lt;S_SYMBOL_LIST_CLOSE&gt;
            ]
          &lt;S_STRUCT_CLOSE&gt;
        }
        &lt;S_EOF&gt;

    States for a shared symbol Table:

        &lt;S_BOF&gt;
        &lt;S_STRUCT&gt;
            $ion_shared_symbol_table::{
          &lt;S_IN_STRUCT&gt;
          &lt;S_NAME&gt;
              name:&quot;mySharedTable&quot;,
          &lt;S_VERSION&gt;
              version:1,
          &lt;S_MAX_ID&gt;
              max_id:3,
          &lt;S_IMPORT_LIST&gt;
              imports:[
            &lt;S_IN_IMPORTS&gt;
            &lt;S_IMPORT_STRUCT&gt;
                {
              &lt;S_IN_IMPORT_STRUCT&gt;
              &lt;S_IMPORT_NAME&gt;
                  name:&quot;otherTable&quot;,
              &lt;S_IMPORT_VERSION&gt;
                  version:2,
              &lt;S_IMPORT_MAX_ID&gt;
                  max_id:192
              &lt;S_IMPORT_STRUCT_CLOSE&gt;
                },
            &lt;S_IMPORT_STRUCT&gt;
                {
              &lt;S_IN_IMPORT_STRUCT&gt;
              &lt;S_IMPORT_NAME&gt;
                  name:&quot;yetAnotherTable&quot;,
              &lt;S_IMPORT_VERSION&gt;
                  version:4,
              &lt;S_IMPORT_MAX_ID&gt;
                  max_id:34
              &lt;S_IMPORT_STRUCT_CLOSE&gt;
                },
            &lt;S_IMPORT_LIST_CLOSE&gt;
              ],
          &lt;S_AFTER_IMPORT_LIST&gt;  new
          &lt;S_SYMBOL_LIST&gt;
              symbols:[
            &lt;S_IN_SYMBOLS&gt;
            &lt;S_SYMBOL&gt;
                &quot;symbol1&quot;,
            &lt;S_SYMBOL&gt;
                &quot;symbol2&quot;,
            &lt;S_SYMBOL&gt;
                &quot;symbol3&quot;
            &lt;S_SYMBOL_LIST_CLOSE&gt;
              ]
          &lt;S_STRUCT_CLOSE&gt;
            }
        &lt;S_EOF&gt;


        Version 1.0 system symbol table:

        &lt;S_BOF&gt;
        &lt;S_STRUCT&gt;
            $ion_symbol_table::{
        &lt;S_IN_STRUCT&gt;
        &lt;S_VERSION&gt;
              version:1,
        &lt;S_MAX_ID&gt;
              max_id:9,
        &lt;S_SYMBOL_LIST&gt;
              symbols:[
        &lt;S_IN_SYMBOLS&gt;
        &lt;S_SYMBOL&gt;
            &quot;$ion&quot;,
        &lt;S_SYMBOL&gt;
            &quot;$ion_1_0&quot;,
        &lt;S_SYMBOL&gt;
            &quot;$ion_symbol_table&quot;,
        &lt;S_SYMBOL&gt;
            &quot;name&quot;,
        &lt;S_SYMBOL&gt;
            &quot;version&quot;,
        &lt;S_SYMBOL&gt;
            &quot;imports&quot;,
        &lt;S_SYMBOL&gt;
            &quot;symbols&quot;,
        &lt;S_SYMBOL&gt;
            &quot;max_id&quot;,
        &lt;S_SYMBOL&gt;
            &quot;$ion_shared_symbol_table&quot;
        &lt;S_SYMBOL_LIST_CLOSE&gt;
              ]
        &lt;S_STRUCT_CLOSE&gt;
            }
        &lt;S_EOF&gt;

 */

/*  --------------------------------------------------------------------------------

Notes regarding the various states that may be encountered.
The reader depth is in parenthesis after the name

state                      next()                  stepIn()                stepOut()                     container
------------------------   ---------------------   ---------------------   -------------------------     ---------
S_BOF(0)                 = S_STRUCT              | &lt;error&gt;                | &lt;error&gt;                    |           |

S_STRUCT(0)              = S_EOF                 | S_IN_STRUCT            | &lt;error&gt;                    | true      |

S_IN_STRUCT(1)           = S_NAME (load)         | &lt;error&gt;                | S_EOF                      |           |
            [if no name] : S_VERSION (load)      | &lt;error&gt;                | S_EOF                      |           |
             [if no ver] : S_MAX_ID (load)       | &lt;error&gt;                | S_EOF                      |           |

S_NAME(1)                = S_VERSION (load)      | &lt;error&gt;                | S_EOF                      |           |
             [if no ver] : S_MAX_ID (load)       | &lt;error&gt;                | S_EOF                      |           |

S_VERSION(1)             = S_MAX_ID (load)       | &lt;error&gt;                | S_EOF                      |           |

S_MAX_ID(1)              = S_IMPORT_LIST (load)  | &lt;error&gt;                | S_EOF                      |           |
         [if no imports] : S_SYMBOL_LIST         | &lt;error&gt;                | S_EOF                      |           |
          [if no locals] : S_EOF                 | &lt;error&gt;                | S_EOF                      |           |

S_IMPORT_LIST(1)         = S_SYMBOL_LIST (load)  | S_IN_IMPORTS           | S_EOF                      | true      |
          [if no locals] : S_EOF                 | &lt;error&gt;                | S_EOF                      |           |

S_IN_IMPORTS(2)          = S_IMPORT_STRUCT       | &lt;error&gt;                | S_AFTER_IMPORT_LIST (load) |           |
    [if no more imports] : S_EOF                 | &lt;error&gt;                | S_AFTER_IMPORT_LIST (load) |           |
          [if no locals] : -------               | -------                | S_STRUCT_CLOSE             |           |

S_IMPORT_STRUCT(2)       = S_IMPORT_STRUCT       | S_IN_IMPORT_STRUCT     | S_AFTER_IMPORT_LIST (load) | true      |
    [if no more imports] : S_IMPORT_STRUCT_CLOSE | &lt;error&gt;                | S_AFTER_IMPORT_LIST (load) |           |
          [if no locals] : -------               | -------                | S_STRUCT_CLOSE             |           |

S_IN_IMPORT_STRUCT(3)    = S_IMPORT_NAME (load)  | &lt;error&gt;                | S_IMPORT_STRUCT            |           |
    [if no more imports] : -------               | -------                | S_IMPORT_STRUCT_CLOSE      |           |

S_IMPORT_NAME(3)         = S_IMPORT_VERSION(load)| &lt;error&gt;                | S_IMPORT_STRUCT            |           |
    [if no more imports] : -------               | -------                | S_IMPORT_STRUCT_CLOSE      |           |

S_IMPORT_VERSION(3)      = S_IMPORT_MAX_ID (load)| &lt;error&gt;                | S_IMPORT_STRUCT            |           |
    [if no more imports] : -------               | -------                | S_IMPORT_STRUCT_CLOSE      |           |

S_IMPORT_MAX_ID(3)       = S_IMPORT_STRUCT_CLOSE | &lt;error&gt;                | S_IMPORT_STRUCT            |           |
    [if no more imports] : -------               | -------                | S_IMPORT_STRUCT_CLOSE      |           |

S_IMPORT_STRUCT_CLOSE(3) = S_IMPORT_STRUCT_CLOSE | &lt;error&gt;                | S_IMPORT_STRUCT            |           |
    [if no more imports] : -------               | -------                | S_STRUCT_CLOSE             |           |

S_IMPORT_LIST_CLOSE(2)   = S_IMPORT_LIST_CLOSE   | &lt;error&gt;                | S_AFTER_IMPORT_LIST (load) |           |
          [if no locals] : S_IMPORT_LIST_CLOSE   | &lt;error&gt;                | S_STRUCT_CLOSE             |           |

S_AFTER_IMPORT_LIST(1)   = S_SYMBOL_LIST         | &lt;error&gt;                | S_EOF                      |           |

S_SYMBOL_LIST(1)         = S_STRUCT_CLOSE        | S_IN_SYMBOLS           | S_EOF                      | true      |
          [if no locals] : -------               | S_SYMBOL_LIST_CLOSE    | S_EOF                      |           |

S_IN_SYMBOLS(2)          = S_SYMBOL (load)       | &lt;error&gt;                | S_STRUCT_CLOSE             |           |
     [if no more locals] : S_SYMBOL_LIST_CLOSE   | &lt;error&gt;                | S_STRUCT_CLOSE             |           |

S_SYMBOL(2)              = S_SYMBOL (load)       | &lt;error&gt;                | S_STRUCT_CLOSE             |           |
     [if no more locals] : S_SYMBOL_LIST_CLOSE   | &lt;error&gt;                | S_STRUCT_CLOSE             |           |

S_SYMBOL_LIST_CLOSE(2)   = S_EOF                 | &lt;error&gt;                | S_STRUCT_CLOSE             |           |

S_STRUCT_CLOSE(1)        = S_EOF                 | &lt;error&gt;                | S_EOF                      |           |
S_EOF(0)                 = S_EOF                 | &lt;error&gt;                | S_EOF                      |           |


Same list sorted by depth (i.e. by the various sequences that
the reader progresses through to a local or global eof)

state
------------------------
S_BOF(0)                   system
S_STRUCT(0)                required
S_EOF(0)                   system


S_IN_STRUCT(1)             system
S_NAME(1)                  optional   if name not null (or if isLocalSymbolTable == false)
S_VERSION(1)               optional   if version &gt; 0  (or if isLocalSymbolTable == false)
S_MAX_ID(1)                optional   if max_id &gt; 0
S_IMPORT_LIST(1)           optional   if import count &gt; 0
S_AFTER_IMPORT_LIST(1)     optional   if import count &gt; 0 &amp;&amp; local count &gt; 0 (this state exists only after stepOut of the import list)
S_SYMBOL_LIST(1)           optional:  if local count &gt; 0
S_STRUCT_CLOSE(1)          system


S_IN_IMPORTS(2)            system
S_IMPORT_STRUCT(2)         variable   if _imports.hasNext() (import symbol table iterator)
S_IMPORT_LIST_CLOSE(2)     system


S_IN_IMPORT_STRUCT(3)      system
S_IMPORT_NAME(3)           required
S_IMPORT_VERSION(3)        required
S_IMPORT_MAX_ID(3)         required
S_IMPORT_STRUCT_CLOSE(3)   system


S_IN_SYMBOLS(2)            system
S_SYMBOL(2)                variable  if _symbols.hasNext() (local symbol iterator)
S_SYMBOL_LIST_CLOSE(2)     system

*/


<span class="pc bpc" id="L296" title="1 of 2 branches missed.">final class SymbolTableReader</span>
    implements IonReader
{

    /**
     * these are the states of the reader.
     * Each state tells the reader it is
     * just before (or on as you might want
     * to think about it) one of the possible
     * values in the serialized image.
     */
    static final int S_BOF                  =  0;
    static final int S_STRUCT               =  1;
    static final int S_IN_STRUCT            =  2;
    static final int S_NAME                 =  3;
    static final int S_VERSION              =  4;
    static final int S_MAX_ID               =  5;
    static final int S_IMPORT_LIST          =  6;
    static final int S_IN_IMPORTS           =  7;
    static final int S_IMPORT_STRUCT        =  8;
    static final int S_IN_IMPORT_STRUCT     =  9;
    static final int S_IMPORT_NAME          = 10;
    static final int S_IMPORT_VERSION       = 11;
    static final int S_IMPORT_MAX_ID        = 12;
    static final int S_IMPORT_STRUCT_CLOSE  = 13;
    static final int S_IMPORT_LIST_CLOSE    = 14;
    static final int S_AFTER_IMPORT_LIST    = 15;
    static final int S_SYMBOL_LIST          = 16;
    static final int S_IN_SYMBOLS           = 17;
    static final int S_SYMBOL               = 18;
    static final int S_SYMBOL_LIST_CLOSE    = 19;
    static final int S_STRUCT_CLOSE         = 20;
    static final int S_EOF                  = 21;

    private final static String get_state_name(int state)
    {
<span class="nc bnc" id="L332" title="All 23 branches missed.">        switch (state) {</span>
<span class="nc" id="L333">        case S_BOF:                     return &quot;S_BOF&quot;;</span>
<span class="nc" id="L334">        case S_STRUCT:                  return &quot;S_STRUCT&quot;;</span>
<span class="nc" id="L335">        case S_IN_STRUCT:               return &quot;S_IN_STRUCT&quot;;</span>
<span class="nc" id="L336">        case S_NAME:                    return &quot;S_NAME&quot;;</span>
<span class="nc" id="L337">        case S_VERSION:                 return &quot;S_VERSION&quot;;</span>
<span class="nc" id="L338">        case S_MAX_ID:                  return &quot;S_MAX_ID&quot;;</span>
<span class="nc" id="L339">        case S_IMPORT_LIST:             return &quot;S_IMPORT_LIST&quot;;</span>
<span class="nc" id="L340">        case S_IN_IMPORTS:              return &quot;S_IN_IMPORTS&quot;;</span>
<span class="nc" id="L341">        case S_IMPORT_STRUCT:           return &quot;S_IMPORT_STRUCT&quot;;</span>
<span class="nc" id="L342">        case S_IN_IMPORT_STRUCT:        return &quot;S_IN_IMPORT_STRUCT&quot;;</span>
<span class="nc" id="L343">        case S_IMPORT_NAME:             return &quot;S_IMPORT_NAME&quot;;</span>
<span class="nc" id="L344">        case S_IMPORT_VERSION:          return &quot;S_IMPORT_VERSION&quot;;</span>
<span class="nc" id="L345">        case S_IMPORT_MAX_ID:           return &quot;S_IMPORT_MAX_ID&quot;;</span>
<span class="nc" id="L346">        case S_IMPORT_STRUCT_CLOSE:     return &quot;S_IMPORT_STRUCT_CLOSE&quot;;</span>
<span class="nc" id="L347">        case S_IMPORT_LIST_CLOSE:       return &quot;S_IMPORT_LIST_CLOSE&quot;;</span>
<span class="nc" id="L348">        case S_AFTER_IMPORT_LIST:       return &quot;S_AFTER_IMPORT_LIST&quot;;</span>
<span class="nc" id="L349">        case S_SYMBOL_LIST:             return &quot;S_SYMBOL_LIST&quot;;</span>
<span class="nc" id="L350">        case S_IN_SYMBOLS:              return &quot;S_IN_SYMBOLS&quot;;</span>
<span class="nc" id="L351">        case S_SYMBOL:                  return &quot;S_SYMBOL&quot;;</span>
<span class="nc" id="L352">        case S_SYMBOL_LIST_CLOSE:       return &quot;S_SYMBOL_LIST_CLOSE&quot;;</span>
<span class="nc" id="L353">        case S_STRUCT_CLOSE:            return &quot;S_STRUCT_CLOSE&quot;;</span>
<span class="nc" id="L354">        case S_EOF:                     return &quot;S_EOF&quot;;</span>
<span class="nc" id="L355">        default:                        return &quot;&lt;Unrecognized state: &quot;+state+&quot;&gt;&quot;;</span>
        }
    }

    static final IonType stateType(int state)
    {
<span class="pc bpc" id="L361" title="11 of 23 branches missed.">        switch (state)</span>
        {
<span class="fc" id="L363">        case S_BOF:                  return null;</span>
<span class="fc" id="L364">        case S_STRUCT:               return IonType.STRUCT;</span>
<span class="nc" id="L365">        case S_IN_STRUCT:            return null;</span>
<span class="fc" id="L366">        case S_NAME:                 return IonType.STRING;</span>
<span class="fc" id="L367">        case S_VERSION:              return IonType.INT;</span>
<span class="nc" id="L368">        case S_MAX_ID:               return IonType.INT;</span>
<span class="fc" id="L369">        case S_IMPORT_LIST:          return IonType.LIST;</span>
<span class="nc" id="L370">        case S_IN_IMPORTS:           return null;</span>
<span class="fc" id="L371">        case S_IMPORT_STRUCT:        return IonType.STRUCT;</span>
<span class="nc" id="L372">        case S_IN_IMPORT_STRUCT:     return null;</span>
<span class="fc" id="L373">        case S_IMPORT_NAME:          return IonType.STRING;</span>
<span class="fc" id="L374">        case S_IMPORT_VERSION:       return IonType.INT;</span>
<span class="fc" id="L375">        case S_IMPORT_MAX_ID:        return IonType.INT;</span>
<span class="nc" id="L376">        case S_IMPORT_STRUCT_CLOSE:  return null;</span>
<span class="nc" id="L377">        case S_IMPORT_LIST_CLOSE:    return null;</span>
<span class="nc" id="L378">        case S_AFTER_IMPORT_LIST:    return null;</span>
<span class="fc" id="L379">        case S_SYMBOL_LIST:          return IonType.LIST;</span>
<span class="nc" id="L380">        case S_IN_SYMBOLS:           return null;</span>
<span class="fc" id="L381">        case S_SYMBOL:               return IonType.STRING;</span>
<span class="nc" id="L382">        case S_SYMBOL_LIST_CLOSE:    return null;</span>
<span class="nc" id="L383">        case S_STRUCT_CLOSE:         return null;</span>
<span class="fc" id="L384">        case S_EOF:                  return null;</span>
        default:
<span class="nc" id="L386">            throwUnrecognizedState(state);</span>
<span class="nc" id="L387">            return null;</span>
        }
    }

    static final int stateDepth(int state)
    {
<span class="pc bpc" id="L393" title="22 of 23 branches missed.">        switch (state)</span>
        {
<span class="fc" id="L395">        case S_BOF:                  return 0;</span>
<span class="nc" id="L396">        case S_STRUCT:               return 0;</span>
<span class="nc" id="L397">        case S_IN_STRUCT:            return 1;</span>
<span class="nc" id="L398">        case S_NAME:                 return 1;</span>
<span class="nc" id="L399">        case S_VERSION:              return 1;</span>
<span class="nc" id="L400">        case S_MAX_ID:               return 1;</span>
<span class="nc" id="L401">        case S_IMPORT_LIST:          return 1;</span>
<span class="nc" id="L402">        case S_IN_IMPORTS:           return 2;</span>
<span class="nc" id="L403">        case S_IMPORT_STRUCT:        return 2;</span>
<span class="nc" id="L404">        case S_IN_IMPORT_STRUCT:     return 3;</span>
<span class="nc" id="L405">        case S_IMPORT_NAME:          return 3;</span>
<span class="nc" id="L406">        case S_IMPORT_VERSION:       return 3;</span>
<span class="nc" id="L407">        case S_IMPORT_MAX_ID:        return 3;</span>
<span class="nc" id="L408">        case S_IMPORT_STRUCT_CLOSE:  return 3;</span>
<span class="nc" id="L409">        case S_IMPORT_LIST_CLOSE:    return 2;</span>
<span class="nc" id="L410">        case S_AFTER_IMPORT_LIST:    return 1;</span>
<span class="nc" id="L411">        case S_SYMBOL_LIST:          return 1;</span>
<span class="nc" id="L412">        case S_IN_SYMBOLS:           return 2;</span>
<span class="nc" id="L413">        case S_SYMBOL:               return 2;</span>
<span class="nc" id="L414">        case S_SYMBOL_LIST_CLOSE:    return 2;</span>
<span class="nc" id="L415">        case S_STRUCT_CLOSE:         return 1;</span>
<span class="nc" id="L416">        case S_EOF:                  return 0;</span>
        default:
<span class="nc" id="L418">            throwUnrecognizedState(state);</span>
<span class="nc" id="L419">            return -1;</span>
        }
    }


    /**
     * these define the bit masked flags used
     * to inform iteration over the optional
     * values that may be present
     */
    private static final int HAS_NAME           = 0x01;
    private static final int HAS_VERSION        = 0x02;
    private static final int HAS_MAX_ID         = 0x04;
    private static final int HAS_IMPORT_LIST    = 0x08;
    private static final int HAS_SYMBOL_LIST    = 0x10;


    /**
     * The symbol table we are reading.
     *
     * We MUST NOT call methods whose value may change! Otherwise there's a
     * thread-safety problem.
     */
    private final SymbolTable _symbol_table;

    private final int _maxId;

    /**
     * _state tracks the progress through the various
     * members, including the substructures in the
     * import list and symbol list.  The previous state
     * is needed when we run into an end of container.
     */
<span class="fc" id="L452">    int _current_state  = S_BOF;</span>

    /**
     * state variables that hold the values referenced
     * by the current reader position.  These are filled
     * in by nextStateDepthFirst() and used by the value
     * getting methods.
     *
     * The iterators are opened when the user steps into
     * one of the two lists (imports and symbols).
     *
     */
    int                          _flags;                  // has name, has ... optional top level values
    String                       _string_value;
    long                         _int_value;
    private SymbolTable[]        _imported_tables;
    private Iterator&lt;SymbolTable&gt; _import_iterator;
    private SymbolTable          _current_import;
    Iterator&lt;String&gt;             _local_symbols;

    public SymbolTableReader(SymbolTable symbol_table)
<span class="fc" id="L473">    {</span>
<span class="fc" id="L474">        _symbol_table = symbol_table;</span>

<span class="fc" id="L476">        synchronized (symbol_table)</span>
        {
<span class="fc" id="L478">            _maxId = symbol_table.getMaxId();</span>
<span class="fc" id="L479">            _local_symbols = symbol_table.iterateDeclaredSymbolNames();</span>
<span class="fc" id="L480">        }</span>

<span class="fc bfc" id="L482" title="All 2 branches covered.">        if (symbol_table.isLocalTable() == false) {</span>
<span class="fc" id="L483">            set_flag(HAS_NAME, true);</span>
<span class="fc" id="L484">            set_flag(HAS_VERSION, true);</span>
        }
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (_maxId &gt; 0) {</span>
            // FIXME: is this ever true?            set_flag(HAS_MAX_ID, true);
        }
<span class="fc" id="L489">        _imported_tables = _symbol_table.getImportedTables();</span>
<span class="fc bfc" id="L490" title="All 4 branches covered.">        if (_imported_tables != null &amp;&amp; _imported_tables.length != 0) {</span>
<span class="fc" id="L491">            set_flag(HAS_IMPORT_LIST, true);</span>
        }
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (_symbol_table.getImportedMaxId() &lt; _maxId) {</span>
<span class="fc" id="L494">            set_flag(HAS_SYMBOL_LIST, true);</span>
        }
<span class="fc" id="L496">    }</span>


    /**
     * @return This implementation always returns null.
     */
    public &lt;T&gt; T asFacet(Class&lt;T&gt; facetType)
    {
<span class="nc" id="L504">        return null;</span>
    }

    //========================================================================


    private final void set_flag(int flag_bit, boolean flag_state)
    {
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">        if (flag_state) {</span>
<span class="fc" id="L513">            _flags |= flag_bit;</span>
        }
        else {
<span class="nc" id="L516">            _flags &amp;= ~flag_bit;</span>
        }
<span class="fc" id="L518">    }</span>

    private final boolean test_flag(int flag_bit)
    {
<span class="fc bfc" id="L522" title="All 2 branches covered.">        boolean flag_state = (_flags &amp; flag_bit) != 0;</span>
<span class="fc" id="L523">        return flag_state;</span>
    }

    final boolean hasName() {
<span class="fc" id="L527">        boolean flag_state = test_flag(HAS_NAME);</span>
<span class="fc" id="L528">        return flag_state;</span>
    }

    final boolean hasVersion() {
<span class="fc" id="L532">        boolean flag_state = test_flag(HAS_VERSION);</span>
<span class="fc" id="L533">        return flag_state;</span>
    }

    final boolean hasMaxId() {
<span class="fc" id="L537">        boolean flag_state = test_flag(HAS_MAX_ID);</span>
<span class="fc" id="L538">        return flag_state;</span>
    }

    final boolean hasImports() {
<span class="fc" id="L542">        boolean flag_state = test_flag(HAS_IMPORT_LIST);</span>
<span class="fc" id="L543">        return flag_state;</span>
    }

    final boolean hasLocalSymbols() {
<span class="fc" id="L547">        boolean flag_state = test_flag(HAS_SYMBOL_LIST);</span>
<span class="fc" id="L548">        return flag_state;</span>
    }


    public boolean hasNext()
    {
<span class="nc" id="L554">        boolean has_next = has_next_helper();</span>
<span class="nc" id="L555">        return has_next;</span>
    }

    private final boolean has_next_helper()
    {
        // this just tells us whether or not we have more
        // value coming at our current scanning depth
<span class="pc bpc" id="L562" title="4 of 17 branches missed.">        switch (_current_state)</span>
        {
        case S_BOF:
            // outer struct always follows
<span class="fc" id="L566">            return true;</span>

        case S_STRUCT:
            // only top level value
<span class="nc" id="L570">            return false;</span>

        case S_IN_STRUCT:
<span class="fc bfc" id="L573" title="All 2 branches covered.">            if (stateFirstInStruct() != S_STRUCT_CLOSE) {</span>
<span class="fc" id="L574">                return true;</span>
            }
<span class="fc" id="L576">            return false;</span>

        case S_NAME:
            // if we have name we have version
<span class="fc" id="L580">            return true;</span>

        case S_VERSION:
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">            if (hasMaxId()) {</span>
<span class="nc" id="L584">                return true;</span>
            }
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">            if (stateFollowingMaxId() != S_STRUCT_CLOSE) {</span>
<span class="fc" id="L587">                return true;</span>
            }
<span class="nc" id="L589">            return false;</span>

        case S_MAX_ID:
            // maybe something follows, but not always
<span class="nc bnc" id="L593" title="All 2 branches missed.">            if (stateFollowingMaxId() != S_STRUCT_CLOSE) {</span>
<span class="nc" id="L594">                return true;</span>
            }
<span class="nc" id="L596">            return false;</span>

        case S_IMPORT_LIST:
            // locals are the only thing that might follow imports
<span class="nc bnc" id="L600" title="All 2 branches missed.">            if (hasLocalSymbols())  return true;</span>
<span class="nc" id="L601">            return false;</span>

        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
            // we have more if there is
<span class="fc" id="L606">            boolean more_imports = _import_iterator.hasNext();</span>
<span class="fc" id="L607">            return more_imports;</span>

        case S_IN_IMPORT_STRUCT:
        case S_IMPORT_NAME:
            // we always have a name and version
<span class="fc" id="L612">            return true;</span>

        case S_IMPORT_VERSION:
            // we always have a max_id on imports
<span class="fc" id="L616">            return true;</span>

        case S_IMPORT_MAX_ID:
        case S_IMPORT_STRUCT_CLOSE:
<span class="fc" id="L620">            return false;</span>

        case S_IMPORT_LIST_CLOSE:
<span class="fc" id="L623">            return false;</span>

        case S_AFTER_IMPORT_LIST:
            // locals are the only thing that might follow imports
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">            if (hasLocalSymbols())  return true;</span>
<span class="nc" id="L628">            return false;</span>

        case S_SYMBOL_LIST:
            // the symbol list is the last member, so it has no &quot;next sibling&quot;
            // but ... just in case we put something after the local symbol list
<span class="pc bpc" id="L633" title="2 of 4 branches missed.">            assert(stateFollowingLocalSymbols() == S_STRUCT_CLOSE);</span>
<span class="fc" id="L634">            return false;</span>

        case S_IN_SYMBOLS:
        case S_SYMBOL:
<span class="fc bfc" id="L638" title="All 2 branches covered.">            if (_local_symbols.hasNext()) return true;</span>
<span class="fc" id="L639">            return false;</span>

        case S_SYMBOL_LIST_CLOSE:
        case S_STRUCT_CLOSE:
        case S_EOF:
            // these are all at the end of their respective containers
<span class="fc" id="L645">            return false;</span>

        default:
<span class="nc" id="L648">            throwUnrecognizedState(_current_state);</span>
<span class="nc" id="L649">            return false;</span>
        }
    }

    private final static void throwUnrecognizedState(int state)
    {
<span class="nc" id="L655">        String message = &quot;Internal error: &quot;</span>
            + &quot;UnifiedSymbolTableReader&quot;
            + &quot; is in an unrecognized state: &quot;
<span class="nc" id="L658">            + get_state_name(state);</span>
<span class="nc" id="L659">        throw new IonException(message);</span>
    }


    // helpers to resolve the existence of a number
    // &quot;follow&quot; states where the answer depends on the
    // details of the symbol table we're reading.

    private final int stateFirstInStruct()
    {
        int new_state;

<span class="fc bfc" id="L671" title="All 2 branches covered.">        if (hasName()) {</span>
<span class="fc" id="L672">            new_state = S_NAME;</span>
        }
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">        else if (hasMaxId()) {</span>
<span class="nc" id="L675">            new_state = S_MAX_ID;</span>
        }
<span class="fc bfc" id="L677" title="All 2 branches covered.">        else if (hasImports()) {</span>
<span class="fc" id="L678">            new_state = S_IMPORT_LIST;</span>
        }
<span class="fc bfc" id="L680" title="All 2 branches covered.">        else if (hasLocalSymbols()) {</span>
<span class="fc" id="L681">            new_state = S_SYMBOL_LIST;</span>
        }
        else {
<span class="fc" id="L684">            new_state = S_STRUCT_CLOSE;</span>
        }
<span class="fc" id="L686">        return new_state;</span>
    }

    private final int stateFollowingMaxId()
    {
        int new_state;

<span class="pc bpc" id="L693" title="1 of 2 branches missed.">        if (hasImports()) {</span>
<span class="nc" id="L694">            new_state = S_IMPORT_LIST;</span>
        }
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">        else if (hasLocalSymbols()) {</span>
<span class="fc" id="L697">            new_state = S_SYMBOL_LIST;</span>
        }
        else {
<span class="nc" id="L700">            new_state = S_STRUCT_CLOSE;</span>
        }
<span class="fc" id="L702">        return new_state;</span>
    }

    private final int nextImport()
    {
<span class="pc bpc" id="L707" title="2 of 4 branches missed.">        assert(_import_iterator != null);</span>

        int new_state;
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">        if (_import_iterator.hasNext()) {</span>
<span class="fc" id="L711">            _current_import = _import_iterator.next();</span>
<span class="fc" id="L712">            new_state = S_IMPORT_STRUCT;</span>
        }
        else {
            // the import list is empty, so we jump to
            // the close list and null out our current
<span class="nc" id="L717">            _current_import = null;</span>
<span class="nc" id="L718">            new_state = S_IMPORT_LIST_CLOSE;</span>
        }
<span class="fc" id="L720">        return new_state;</span>
    }

<span class="fc" id="L723">    private static enum Op {NEXT, STEPOUT}</span>
    private final int stateFollowingImportList(Op op)
    {
<span class="fc" id="L726">        int new_state = -1;</span>

<span class="fc bfc" id="L728" title="All 2 branches covered.">        if (hasLocalSymbols()) {</span>
<span class="pc bpc" id="L729" title="2 of 3 branches missed.">            switch (op) {</span>
            case NEXT:
<span class="nc" id="L731">                new_state = S_SYMBOL_LIST;</span>
<span class="nc" id="L732">                break;</span>
            case STEPOUT:
<span class="fc" id="L734">                new_state = S_AFTER_IMPORT_LIST;</span>
<span class="fc" id="L735">                break;</span>
            }
        }
        else {
<span class="fc" id="L739">            new_state = S_STRUCT_CLOSE;</span>
        }
<span class="fc" id="L741">        return new_state;</span>
    }

    private final int stateFollowingLocalSymbols()
    {
<span class="fc" id="L746">        return S_STRUCT_CLOSE;</span>
    }

    /**
     * this computes the actual move to the next state
     *
     * It does take into account the existence or absence
     * of various properties, such as the symbol table
     * name which is only present in some symbol tables.
     *
     * This also fills in a variety of current state
     * variables that are used to return correct values
     * by the &quot;get&quot; methods.
     *
     */
    public IonType next()
    {
<span class="fc bfc" id="L763" title="All 2 branches covered.">        if (has_next_helper() == false) {</span>
<span class="fc" id="L764">            return null;</span>
        }
        int new_state;

<span class="pc bpc" id="L768" title="11 of 22 branches missed.">        switch (_current_state)</span>
        {
        case S_BOF:
<span class="fc" id="L771">            new_state = S_STRUCT;</span>
<span class="fc" id="L772">            break;</span>

        case S_STRUCT:
<span class="nc" id="L775">            new_state = S_EOF;</span>
<span class="nc" id="L776">            break;</span>

        case S_IN_STRUCT:
<span class="fc" id="L779">            new_state = stateFirstInStruct();</span>
<span class="fc" id="L780">            loadStateData(new_state);</span>
<span class="fc" id="L781">            break;</span>

        case S_NAME:
<span class="pc bpc" id="L784" title="2 of 4 branches missed.">            assert(hasVersion());</span>
<span class="fc" id="L785">            new_state = S_VERSION;</span>
<span class="fc" id="L786">            loadStateData(new_state);</span>
<span class="fc" id="L787">            break;</span>

        case S_VERSION:
<span class="pc bpc" id="L790" title="1 of 2 branches missed.">            if (hasMaxId()) {</span>
<span class="nc" id="L791">                new_state = S_MAX_ID;</span>
<span class="nc" id="L792">                loadStateData(new_state);</span>
            }
            else {
<span class="fc" id="L795">                new_state = stateFollowingMaxId();</span>
            }
<span class="fc" id="L797">            break;</span>

        case S_MAX_ID:
<span class="nc" id="L800">            new_state = stateFollowingMaxId();</span>
<span class="nc" id="L801">            break;</span>

        case S_IMPORT_LIST:
<span class="nc" id="L804">            new_state = this.stateFollowingImportList(Op.NEXT);</span>
<span class="nc" id="L805">            break;</span>

        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
            // we only need to get the import list once, which we
            // do as we step into the import list, so it should
            // be waiting for us here.
<span class="pc bpc" id="L812" title="2 of 4 branches missed.">            assert(_import_iterator != null);</span>
<span class="fc" id="L813">            new_state = nextImport();</span>
<span class="fc" id="L814">            break;</span>

        case S_IN_IMPORT_STRUCT:
            // shared tables have to have a name
<span class="fc" id="L818">            new_state = S_IMPORT_NAME;</span>
<span class="fc" id="L819">            loadStateData(new_state);</span>
<span class="fc" id="L820">            break;</span>

        case S_IMPORT_NAME:
            // shared tables have to have a version
<span class="fc" id="L824">            new_state = S_IMPORT_VERSION;</span>
<span class="fc" id="L825">            loadStateData(new_state);</span>
<span class="fc" id="L826">            break;</span>

        case S_IMPORT_VERSION:
            // and they also always have a max id - so we set up
            // for it
<span class="fc" id="L831">            new_state = S_IMPORT_MAX_ID;</span>
<span class="fc" id="L832">            loadStateData(new_state);</span>
<span class="fc" id="L833">            break;</span>

        case S_IMPORT_MAX_ID:
<span class="nc" id="L836">            new_state = S_IMPORT_STRUCT_CLOSE;</span>
<span class="nc" id="L837">            break;</span>

        case S_IMPORT_STRUCT_CLOSE:
            // no change here - we just bump up against this local eof
<span class="nc" id="L841">            new_state = S_IMPORT_STRUCT_CLOSE;</span>
<span class="nc" id="L842">            break;</span>

        case S_IMPORT_LIST_CLOSE:
            // no change here - we just bump up against this local eof
<span class="nc" id="L846">            new_state = S_IMPORT_LIST_CLOSE;</span>
<span class="nc" id="L847">            break;</span>

        case S_AFTER_IMPORT_LIST:
<span class="pc bpc" id="L850" title="2 of 4 branches missed.">            assert(_symbol_table.getImportedMaxId() &lt; _maxId);</span>
<span class="fc" id="L851">            new_state = S_SYMBOL_LIST;</span>
<span class="fc" id="L852">            break;</span>

        case S_SYMBOL_LIST:
<span class="nc bnc" id="L855" title="All 4 branches missed.">            assert(_symbol_table.getImportedMaxId() &lt; _maxId);</span>
<span class="nc" id="L856">            new_state = stateFollowingLocalSymbols();</span>
<span class="nc" id="L857">            break;</span>

        case S_IN_SYMBOLS:
            // we have some symbols - so we'll set up to read them,
            // which we *have* to do once and *need* to do only once.
<span class="pc bpc" id="L862" title="2 of 4 branches missed.">            assert(_local_symbols != null);</span>
            // since we only get into the symbol list if
            // there are some symbols - our next state
            // is at the first symbol
<span class="pc bpc" id="L866" title="2 of 4 branches missed.">            assert(_local_symbols.hasNext() == true);</span>
            // so we just fall through to and let the S_SYMBOL
            // state do it's thing (which it will do every time
            // we move to the next symbol)
        case S_SYMBOL:
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">            if (_local_symbols.hasNext())</span>
            {
<span class="fc" id="L873">                _string_value = _local_symbols.next();</span>
                // null means this symbol isn't defined
<span class="fc" id="L875">                new_state = S_SYMBOL;</span>
            }
            else {
<span class="nc" id="L878">                new_state = S_SYMBOL_LIST_CLOSE;</span>
            }
<span class="nc" id="L880">            break;</span>

        case S_SYMBOL_LIST_CLOSE:
            // no change here - we just bump up against this local eof
<span class="nc" id="L884">            new_state = S_SYMBOL_LIST_CLOSE;</span>
<span class="nc" id="L885">            break;</span>

        case S_STRUCT_CLOSE:
            // no change here - we just bump up against this local eof
<span class="nc" id="L889">            new_state = S_STRUCT_CLOSE;</span>
<span class="nc" id="L890">            break;</span>

        case S_EOF:
<span class="nc" id="L893">            new_state = S_EOF;</span>
<span class="nc" id="L894">            break;</span>

        default:
<span class="nc" id="L897">            throwUnrecognizedState(_current_state);</span>
<span class="nc" id="L898">            new_state = -1;</span>
            break;
        }

<span class="fc" id="L902">        _current_state = new_state;</span>
<span class="fc" id="L903">        return stateType(_current_state);</span>
    }


    private final void loadStateData(int new_state)
    {
<span class="pc bpc" id="L909" title="2 of 8 branches missed.">        switch(new_state) {</span>
        case S_NAME:
<span class="pc bpc" id="L911" title="2 of 4 branches missed.">            assert(hasName());</span>
<span class="fc" id="L912">            String name = _symbol_table.getName();</span>
<span class="fc" id="L913">            _string_value = name;</span>
<span class="pc bpc" id="L914" title="2 of 4 branches missed.">            assert(_string_value != null);</span>
            break;

        case S_VERSION:
<span class="fc" id="L918">            int value = _symbol_table.getVersion();</span>
<span class="fc" id="L919">            _int_value = value;</span>
<span class="pc bpc" id="L920" title="2 of 4 branches missed.">            assert(value != 0);</span>
            break;

        case S_MAX_ID:
<span class="nc" id="L924">            _int_value = _maxId;</span>
<span class="nc" id="L925">            break;</span>

        case S_IMPORT_LIST:
        case S_SYMBOL_LIST:
            // no op to simplify the initial fields logic in next()
<span class="fc" id="L930">            break;</span>

        case S_IMPORT_NAME:
<span class="pc bpc" id="L933" title="2 of 4 branches missed.">            assert(_current_import != null);</span>
<span class="fc" id="L934">            _string_value = _current_import.getName();</span>
<span class="fc" id="L935">            break;</span>

        case S_IMPORT_VERSION:
            // shared tables have to have a version
<span class="fc" id="L939">            _string_value = null;</span>
<span class="fc" id="L940">            _int_value = _current_import.getVersion();</span>
<span class="fc" id="L941">            break;</span>

        case S_IMPORT_MAX_ID:
            // and they also always have a max id - so we set up
            // for it
<span class="fc" id="L946">            _int_value = _current_import.getMaxId();</span>
<span class="fc" id="L947">            break;</span>

        default:
<span class="nc" id="L950">            String message = &quot;UnifiedSymbolTableReader in state &quot;</span>
<span class="nc" id="L951">                           + SymbolTableReader.get_state_name(new_state)</span>
                           + &quot; has no state to load.&quot;;
<span class="nc" id="L953">            throw new IonException(message);</span>
        }
<span class="fc" id="L955">    }</span>

    public void stepIn()
    {
        int new_state;

<span class="pc bpc" id="L961" title="1 of 5 branches missed.">        switch (_current_state) {</span>
        case S_STRUCT:
<span class="fc" id="L963">            new_state = S_IN_STRUCT;</span>
<span class="fc" id="L964">            break;</span>
        case S_IMPORT_LIST:
<span class="fc" id="L966">            _import_iterator = Arrays.asList(_imported_tables).iterator();</span>
<span class="fc" id="L967">            new_state = S_IN_IMPORTS;</span>
<span class="fc" id="L968">            break;</span>
        case S_IMPORT_STRUCT:
<span class="pc bpc" id="L970" title="2 of 4 branches missed.">            assert(_current_import != null);</span>
<span class="fc" id="L971">            new_state = S_IN_IMPORT_STRUCT;</span>
<span class="fc" id="L972">            break;</span>
        case S_SYMBOL_LIST:
<span class="fc" id="L974">            new_state = S_IN_SYMBOLS;</span>
<span class="fc" id="L975">            break;</span>
        default:
<span class="nc" id="L977">            throw new IllegalStateException(&quot;current value is not a container&quot;);</span>
        }

<span class="fc" id="L980">        _current_state = new_state;</span>
<span class="fc" id="L981">        return;</span>
    }

    public void stepOut()
    {
<span class="fc" id="L986">        int new_state = -1;</span>

<span class="pc bpc" id="L988" title="1 of 5 branches missed.">        switch (_current_state) {</span>
            case S_IN_STRUCT:
            case S_NAME:
            case S_VERSION:
            case S_MAX_ID:
            case S_IMPORT_LIST:
            case S_AFTER_IMPORT_LIST:
            case S_SYMBOL_LIST:
            case S_STRUCT_CLOSE:
                // these are all top level so stepOut()
                // ends up at the end of our data
<span class="fc" id="L999">                new_state = S_EOF;</span>
<span class="fc" id="L1000">                break;</span>

            case S_IN_IMPORTS:
            case S_IMPORT_STRUCT:
            case S_IMPORT_LIST_CLOSE:
                // if we're outside a struct, and we're in the import
                // list stepOut will be whatever follows the import list
                // close and we're done with these
<span class="fc" id="L1008">                _current_import = null;</span>
<span class="fc" id="L1009">                _import_iterator = null;</span>
<span class="fc" id="L1010">                new_state = stateFollowingImportList(Op.STEPOUT);</span>
<span class="fc" id="L1011">                break;</span>

            case S_IN_IMPORT_STRUCT:
            case S_IMPORT_NAME:
            case S_IMPORT_VERSION:
            case S_IMPORT_MAX_ID:
            case S_IMPORT_STRUCT_CLOSE:
                // if there is a next import the next state
                // will be its struct open
                // otherwise next will be the list close
<span class="fc bfc" id="L1021" title="All 2 branches covered.">                if (_import_iterator.hasNext()) {</span>
<span class="fc" id="L1022">                    new_state = S_IMPORT_STRUCT;</span>
                }
                else {
<span class="fc" id="L1025">                    new_state = S_IMPORT_LIST_CLOSE;</span>
                }
<span class="fc" id="L1027">                break;</span>

            case S_IN_SYMBOLS:
            case S_SYMBOL:
            case S_SYMBOL_LIST_CLOSE:
                // I think this is just S_EOF, but if we ever
                // put anything after the symbol list this
                // will need to be updated.  And we're done
                // with our local symbol references.
<span class="fc" id="L1036">                _string_value = null;</span>
<span class="fc" id="L1037">                _local_symbols = null;</span>
<span class="fc" id="L1038">                new_state = stateFollowingLocalSymbols();</span>
<span class="fc" id="L1039">                break;</span>

            default:
<span class="nc" id="L1042">                throw new IllegalStateException(&quot;current value is not in a container&quot;);</span>
        }

<span class="fc" id="L1045">        _current_state = new_state;</span>
<span class="fc" id="L1046">        return;</span>
    }

    public int getDepth()
    {
<span class="fc" id="L1051">        return stateDepth(_current_state);</span>
    }

    public SymbolTable getSymbolTable()
    {
        // TODO: this should return a system symbol table
        //       but, for now, we don't really know which
        //       one to return;
        //
        // UnifiedSymbolTable.makeSystemSymbolTable(_sys, _version);
        //
        // although, with this reader in place we should be
        // able to cons one up without a system
<span class="nc" id="L1064">        return null;</span>
    }

    public IonType getType()
    {
<span class="fc" id="L1069">        return stateType(_current_state);</span>
    }


    public String[] getTypeAnnotations()
    {
<span class="nc bnc" id="L1075" title="All 2 branches missed.">        if (_current_state == S_STRUCT) {</span>
            // Must return a new array each time to prevent user from changing it
<span class="nc bnc" id="L1077" title="All 4 branches missed.">            if (_symbol_table.isLocalTable() || _symbol_table.isSystemTable())</span>
            {
<span class="nc" id="L1079">                return new String[] { ION_SYMBOL_TABLE };</span>
            }
<span class="nc" id="L1081">            return new String[] { ION_SHARED_SYMBOL_TABLE };</span>
        }
<span class="nc" id="L1083">        return _Private_Utils.EMPTY_STRING_ARRAY;</span>
    }

<span class="fc" id="L1086">    private static final SymbolToken ION_SYMBOL_TABLE_SYM =</span>
<span class="fc" id="L1087">        newSymbolToken(ION_SYMBOL_TABLE, ION_SYMBOL_TABLE_SID);</span>

<span class="fc" id="L1089">    private static final SymbolToken ION_SHARED_SYMBOL_TABLE_SYM =</span>
<span class="fc" id="L1090">        newSymbolToken(ION_SHARED_SYMBOL_TABLE, ION_SHARED_SYMBOL_TABLE_SID);</span>

    public SymbolToken[] getTypeAnnotationSymbols()
    {
<span class="fc bfc" id="L1094" title="All 2 branches covered.">        if (_current_state == S_STRUCT) {</span>
            SymbolToken sym;
<span class="pc bpc" id="L1096" title="1 of 4 branches missed.">            if (_symbol_table.isLocalTable() || _symbol_table.isSystemTable())</span>
            {
<span class="fc" id="L1098">                sym = ION_SYMBOL_TABLE_SYM;</span>
            }
            else
            {
<span class="fc" id="L1102">                sym = ION_SHARED_SYMBOL_TABLE_SYM;</span>
            }

            // Must return a new array each time to prevent user from changing it
<span class="fc" id="L1106">            return new SymbolToken[] { sym };</span>
        }
<span class="fc" id="L1108">        return SymbolToken.EMPTY_ARRAY;</span>
    }


    public Iterator&lt;String&gt; iterateTypeAnnotations()
    {
<span class="nc" id="L1114">        String[] annotations = getTypeAnnotations();</span>
<span class="nc" id="L1115">        return _Private_Utils.stringIterator(annotations);</span>
    }


    public int getFieldId()
    {

<span class="nc bnc" id="L1122" title="All 7 branches missed.">        switch (_current_state)</span>
        {
        case S_STRUCT:
        case S_IN_STRUCT:
        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
        case S_IN_IMPORT_STRUCT:
        case S_IMPORT_STRUCT_CLOSE:
        case S_IMPORT_LIST_CLOSE:
        case S_AFTER_IMPORT_LIST:
        case S_IN_SYMBOLS:
        case S_SYMBOL:
        case S_SYMBOL_LIST_CLOSE:
        case S_STRUCT_CLOSE:
        case S_EOF:
<span class="nc" id="L1137">            return SymbolTable.UNKNOWN_SYMBOL_ID;</span>

        case S_NAME:
        case S_IMPORT_NAME:
<span class="nc" id="L1141">            return NAME_SID;</span>

        case S_VERSION:
        case S_IMPORT_VERSION:
<span class="nc" id="L1145">            return VERSION_SID;</span>

        case S_MAX_ID:
        case S_IMPORT_MAX_ID:
<span class="nc" id="L1149">            return MAX_ID_SID;</span>

        case S_IMPORT_LIST:
<span class="nc" id="L1152">            return IMPORTS_SID;</span>

        case S_SYMBOL_LIST:
<span class="nc" id="L1155">            return SYMBOLS_SID;</span>

        default:
<span class="nc" id="L1158">            throw new IonException(&quot;Internal error: UnifiedSymbolTableReader is in an unrecognized state: &quot;+_current_state);</span>
        }
    }

    public String getFieldName()
    {
<span class="pc bpc" id="L1164" title="5 of 7 branches missed.">        switch (_current_state)</span>
        {
        case S_STRUCT:
        case S_IN_STRUCT:
        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
        case S_IN_IMPORT_STRUCT:
        case S_IMPORT_STRUCT_CLOSE:
        case S_IMPORT_LIST_CLOSE:
        case S_AFTER_IMPORT_LIST:
        case S_IN_SYMBOLS:
        case S_SYMBOL:
        case S_SYMBOL_LIST_CLOSE:
        case S_STRUCT_CLOSE:
        case S_EOF:
<span class="nc" id="L1179">            return null;</span>

        case S_NAME:
        case S_IMPORT_NAME:
<span class="nc" id="L1183">            return NAME;</span>

        case S_VERSION:
        case S_IMPORT_VERSION:
<span class="nc" id="L1187">            return VERSION;</span>

        case S_MAX_ID:
        case S_IMPORT_MAX_ID:
<span class="nc" id="L1191">            return MAX_ID;</span>

        case S_IMPORT_LIST:
<span class="fc" id="L1194">            return IMPORTS;</span>

        case S_SYMBOL_LIST:
<span class="fc" id="L1197">            return SYMBOLS;</span>

        default:
<span class="nc" id="L1200">            throw new IonException(&quot;Internal error: UnifiedSymbolTableReader is in an unrecognized state: &quot;+_current_state);</span>
        }
    }

    public SymbolToken getFieldNameSymbol()
    {
<span class="pc bpc" id="L1206" title="1 of 7 branches missed.">        switch (_current_state)</span>
        {
        case S_STRUCT:
        case S_IN_STRUCT:
        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
        case S_IN_IMPORT_STRUCT:
        case S_IMPORT_STRUCT_CLOSE:
        case S_IMPORT_LIST_CLOSE:
        case S_AFTER_IMPORT_LIST:
        case S_IN_SYMBOLS:
        case S_SYMBOL:
        case S_SYMBOL_LIST_CLOSE:
        case S_STRUCT_CLOSE:
        case S_EOF:
<span class="fc" id="L1221">            return null;</span>

        case S_NAME:
        case S_IMPORT_NAME:
<span class="fc" id="L1225">            return new SymbolTokenImpl(NAME, NAME_SID);</span>

        case S_VERSION:
        case S_IMPORT_VERSION:
<span class="fc" id="L1229">            return new SymbolTokenImpl(VERSION, VERSION_SID);</span>

        case S_MAX_ID:
        case S_IMPORT_MAX_ID:
<span class="fc" id="L1233">            return new SymbolTokenImpl(MAX_ID, MAX_ID_SID);</span>

        case S_IMPORT_LIST:
<span class="fc" id="L1236">            return new SymbolTokenImpl(IMPORTS, IMPORTS_SID);</span>

        case S_SYMBOL_LIST:
<span class="fc" id="L1239">            return new SymbolTokenImpl(SYMBOLS, SYMBOLS_SID);</span>

        default:
<span class="nc" id="L1242">            throw new IonException(&quot;Internal error: UnifiedSymbolTableReader is in an unrecognized state: &quot;+_current_state);</span>
        }
    }

    public boolean isNullValue()
    {
<span class="pc bpc" id="L1248" title="1 of 3 branches missed.">        switch (_current_state)</span>
        {
        case S_STRUCT:
        case S_IN_STRUCT:
        case S_NAME:
        case S_VERSION:
        case S_MAX_ID:
        case S_IMPORT_LIST:
        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
        case S_IN_IMPORT_STRUCT:
        case S_IMPORT_NAME:
        case S_IMPORT_VERSION:
        case S_IMPORT_MAX_ID:
        case S_IN_SYMBOLS:
        case S_SYMBOL:
            // these values are either present and non-null
            // or entirely absent (in which case they will
            // have been skipped and we won't be in a state
            // to return them).
<span class="fc" id="L1268">            return false;</span>

        case S_IMPORT_STRUCT_CLOSE:
        case S_IMPORT_LIST_CLOSE:
        case S_AFTER_IMPORT_LIST:
        case S_SYMBOL_LIST:
        case S_SYMBOL_LIST_CLOSE:
        case S_STRUCT_CLOSE:
        case S_EOF:
            // here we're not really on a value, so we're not
            // on a value that is a null - so false again.
<span class="fc" id="L1279">            return false;</span>

        default:
<span class="nc" id="L1282">            throw new IonException(&quot;Internal error: UnifiedSymbolTableReader is in an unrecognized state: &quot;+_current_state);</span>
        }
    }

    public boolean isInStruct()
    {
<span class="nc bnc" id="L1288" title="All 5 branches missed.">        switch (_current_state)</span>
        {
        case S_STRUCT:
        case S_IN_IMPORTS:
        case S_IMPORT_STRUCT:
        case S_IN_SYMBOLS:
        case S_SYMBOL:
            // these values are either not contained, or
            // contained in a list.  So we aren't in a
            // struct if they're pending.
<span class="nc" id="L1298">            return false;</span>

        case S_IN_STRUCT:
        case S_NAME:
        case S_VERSION:
        case S_MAX_ID:
        case S_IMPORT_LIST:
        case S_IN_IMPORT_STRUCT:
        case S_IMPORT_NAME:
        case S_IMPORT_VERSION:
        case S_IMPORT_MAX_ID:
        case S_AFTER_IMPORT_LIST:
        case S_SYMBOL_LIST:
            // the values above are all members
            // of a struct, so we must be in a
            // struct to have them pending
<span class="nc" id="L1314">            return true;</span>

        case S_IMPORT_STRUCT_CLOSE:
        case S_STRUCT_CLOSE:
            // if we're closing a struct we're in a struct
<span class="nc" id="L1319">            return true;</span>

        case S_IMPORT_LIST_CLOSE:
        case S_SYMBOL_LIST_CLOSE:
        case S_EOF:
            // if we're closing a list we in a list, not a struct
            // and EOF is not in a struct
<span class="nc" id="L1326">            return false;</span>

        default:
<span class="nc" id="L1329">            throw new IonException(&quot;Internal error: UnifiedSymbolTableReader is in an unrecognized state: &quot;+_current_state);</span>
        }
    }

    public boolean booleanValue()
    {
<span class="nc" id="L1335">        throw new IllegalStateException(&quot;only valid if the value is a boolean&quot;);</span>
    }

    public int intValue()
    {
<span class="fc" id="L1340">        return (int)_int_value;</span>
    }

    public long longValue()
    {
<span class="nc" id="L1345">        return _int_value;</span>
    }

    public BigInteger bigIntegerValue()
    {
<span class="fc" id="L1350">        String value = Long .toString(_int_value);</span>
<span class="fc" id="L1351">        BigInteger bi = new BigInteger(value);     // this is SOOOOO broken &lt;sigh&gt;</span>
<span class="fc" id="L1352">        return bi;</span>
    }

    public double doubleValue()
    {
<span class="nc" id="L1357">        throw new IllegalStateException(&quot;only valid if the value is a double&quot;);</span>
    }

    public BigDecimal bigDecimalValue()
    {
<span class="nc" id="L1362">        throw new IllegalStateException(&quot;only valid if the value is a decimal&quot;);    }</span>

    public Decimal decimalValue()
    {
<span class="nc" id="L1366">        throw new IllegalStateException(&quot;only valid if the value is a decimal&quot;);</span>
    }

    public Date dateValue()
    {
<span class="nc" id="L1371">        throw new IllegalStateException(&quot;only valid if the value is a timestamp&quot;);</span>
    }

    public Timestamp timestampValue()
    {
<span class="nc" id="L1376">        throw new IllegalStateException(&quot;only valid if the value is a timestamp&quot;);</span>
    }

    public String stringValue()
    {
<span class="fc" id="L1381">        return _string_value;</span>
    }

    public SymbolToken symbolValue()
    {
        // TODO handle null
<span class="nc" id="L1387">        throw new UnsupportedOperationException();</span>
    }

    public int getBytes(byte[] buffer, int offset, int len)
    {
<span class="nc" id="L1392">        throw new IllegalStateException(&quot;getBytes() is only valid if the reader is on a lob value, not a &quot;+stateType(_current_state)+&quot; value&quot;);</span>
    }

    public int byteSize()
    {
<span class="nc" id="L1397">        throw new IllegalStateException(&quot;byteSize() is only valid if the reader is on a lob value, not a &quot;+stateType(_current_state)+&quot; value&quot;);</span>
    }

    public byte[] newBytes()
    {
<span class="nc" id="L1402">        throw new IllegalStateException(&quot;newBytes() is only valid if the reader is on a lob value, not a &quot;+stateType(_current_state)+&quot; value&quot;);</span>
    }

    public void close() throws IOException
    {
<span class="nc" id="L1407">        _current_state = S_EOF;</span>
<span class="nc" id="L1408">    }</span>

    public IntegerSize getIntegerSize()
    {
<span class="pc bpc" id="L1412" title="1 of 2 branches missed.">        if (stateType(_current_state) != IonType.INT)</span>
        {
<span class="nc" id="L1414">            return null;</span>
        }
<span class="fc" id="L1416">        return IntegerSize.INT; // all of SymbolTable's integers are type int</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>