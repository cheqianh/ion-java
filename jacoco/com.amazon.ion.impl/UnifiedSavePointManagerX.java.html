<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnifiedSavePointManagerX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">UnifiedSavePointManagerX.java</span></div><h1>UnifiedSavePointManagerX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;


/**
 *   These classes (UnifiedSavePointManager and the contained
 *   SavePoint) isolate the save point handing. Its effect spans
 *   both the input stream and the underlying buffer - so the manager
 *   keeps it's own reference to these.  By doing so this should
 *   make save points easier to use.  It grabs the buffer from
 *   the stream since it need a reference to the UnifiedInputBuffer
 *   on most calls and doesn't need an extra de-ref (mostly for
 *   code clarity)
 *
 *   The general life time of a save point is:
 *   . allocate a save point
 *   . . start the save point, which sets the start idx and pos - and
 *       pins the buffer pages with a use count
 *   . . mark_end the save point, which sets the end idx and pos
 *   . . . activate the save point, which sets the input streams pos
 *         to the start
 *   . . . deactivate the save point, which pops the save point stack
 *         and restores the stream to its previous position
 *   . . clear the save point. this clears its internal values and
 *       releases its use counter on the buffer. As the buffers in use
 *       count goes to zero it may release any unnecessary pages.
 *   . free the save point
 *
 *   this order of operation, as nested above, is enforced by checking
 *   the state of the save points and member values like the end position.
 *
 *   if the end position is not set it is treated as &quot;to end of file&quot;
 *
 */
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">final class UnifiedSavePointManagerX</span>
{
    private static final int FREE_LIST_LIMIT = 20;

    UnifiedInputStreamX  _stream;
    UnifiedInputBufferX  _buffer;
    SavePoint           _inuse;
    SavePoint           _free;
    int                 _free_count;
    SavePoint           _active_stack;
    int                 _open_save_points;

<span class="fc" id="L61">    public UnifiedSavePointManagerX(UnifiedInputStreamX  stream) {</span>
<span class="fc" id="L62">        _stream = stream;</span>
<span class="fc" id="L63">        _buffer = stream._buffer;</span>
<span class="fc" id="L64">        _inuse = null;</span>
<span class="fc" id="L65">        _free = null;</span>
<span class="fc" id="L66">        _active_stack = null;</span>
<span class="fc" id="L67">    }</span>

    public final boolean isSavePointOpen() {
<span class="fc bfc" id="L70" title="All 2 branches covered.">        return (_open_save_points &gt; 0);</span>
    }

    public final long lengthOf(SavePoint sp)
    {
<span class="fc" id="L75">        int start_idx = sp.getStartIdx();</span>
<span class="fc" id="L76">        int end_idx   = sp.getEndIdx();</span>

<span class="pc bpc" id="L78" title="2 of 4 branches missed.">        if (start_idx == -1 || end_idx == -1) {</span>
<span class="nc" id="L79">            return 0;</span>
        }

        long len;
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        if (start_idx == end_idx) {  // a very common case</span>
<span class="fc" id="L84">            int start_pos = sp.getStartPos();</span>
<span class="fc" id="L85">            int end_pos   = sp.getEndPos();</span>
<span class="fc" id="L86">            len = end_pos - start_pos;</span>
<span class="fc" id="L87">        }</span>
        else {
<span class="nc" id="L89">            UnifiedDataPageX start = _buffer.getPage(start_idx);</span>
<span class="nc" id="L90">            UnifiedDataPageX end   = _buffer.getPage(end_idx);</span>
<span class="nc" id="L91">            long start_pos = start.getFilePosition(sp.getStartPos());</span>
<span class="nc" id="L92">            long end_pos   = end.getFilePosition(sp.getEndPos());</span>
<span class="nc" id="L93">            len = end_pos - start_pos;</span>
        }
<span class="fc" id="L95">        return len;</span>
    }

    public final SavePoint savePointAllocate() {
        SavePoint sp;
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if (_free != null) {</span>
<span class="nc" id="L101">            sp = _free;</span>
<span class="nc" id="L102">            _free = sp._next;</span>
<span class="nc" id="L103">            _free_count--;</span>
<span class="nc" id="L104">            sp.clear();</span>
        }
        else {
<span class="fc" id="L107">            sp = new SavePoint(this);</span>
        }
<span class="fc" id="L109">        sp._next = _inuse;</span>
<span class="fc" id="L110">        sp._prev = null;</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        if (_inuse != null) {</span>
<span class="nc" id="L112">            _inuse._prev = sp;</span>
        }
        else {
<span class="fc" id="L115">            _inuse = sp;</span>
        }
<span class="fc" id="L117">        return sp;</span>
    }
    public final void savePointFree(SavePoint sp)
    {
<span class="nc bnc" id="L121" title="All 4 branches missed.">        assert(sp.isClear());</span>

<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (_free_count &gt;= FREE_LIST_LIMIT) {</span>
            // by not putting this on the free list
            // the GC is free to clean it up.
<span class="nc" id="L126">            return;</span>
        }

<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (sp._prev == null) {</span>
<span class="nc" id="L130">            sp._prev = sp._next;</span>
        }
        else {
<span class="nc" id="L133">            _inuse = sp._next;</span>
        }
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (sp._next  != null) {</span>
<span class="nc" id="L136">            sp._next._prev = sp._prev;</span>
        }
<span class="nc" id="L138">        sp._next = _free;</span>
<span class="nc" id="L139">        _free = sp;</span>
<span class="nc" id="L140">        _free_count++;</span>
<span class="nc" id="L141">    }</span>
    public final SavePoint savePointActiveTop() {
<span class="fc" id="L143">        return _active_stack;</span>
    }

    public final void savePointPushActive(SavePoint sp, long line_number, long line_start) {
<span class="pc bpc" id="L147" title="2 of 4 branches missed.">        assert(!sp.isActive());</span>

<span class="fc" id="L149">        int      idx = _buffer.getCurrentPageIdx();</span>
<span class="fc" id="L150">        int      pos = _stream._pos;</span>
<span class="fc" id="L151">        int      limit = _stream._limit;</span>
<span class="fc" id="L152">        UnifiedDataPageX curr = _buffer.getPage(idx);</span>

        // save our current state in the Save Point so when
        // we pop it off we can restore our current state
<span class="fc" id="L156">        sp.set_prev_pos(idx, pos, limit, line_number, line_start);</span>

        // actually push this save point on the stack
<span class="fc" id="L159">        sp._next_active = _active_stack;</span>
<span class="fc" id="L160">        _active_stack = sp;</span>
<span class="fc" id="L161">        sp.set_active();</span>

        // if the start page is also the last page we
        // need set the limit to the sp end, otherwise
        // we use the limit from the page and we'll
        // deal with the last page when we get to it
<span class="fc" id="L167">        idx = sp.getStartIdx();</span>
<span class="fc" id="L168">        pos = sp.getStartPos();</span>
<span class="fc" id="L169">        curr = _buffer.getPage(idx);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (sp.getEndIdx() != sp.getStartIdx()) {</span>
<span class="fc" id="L171">            limit = curr.getBufferLimit();</span>
        }
        else {
<span class="fc" id="L174">            limit = sp.getEndPos();</span>
        }
<span class="fc" id="L176">        _stream.make_page_current(curr, idx, pos, limit);</span>
<span class="fc" id="L177">    }</span>

    public final void savePointPopActive(SavePoint sp)
    {
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (sp != _active_stack) {</span>
<span class="nc" id="L182">            throw new IllegalArgumentException(&quot;save point being released isn't currently active&quot;);</span>
        }

<span class="fc" id="L185">        _active_stack = sp._next_active;</span>
<span class="fc" id="L186">        sp._next_active = null;</span>
<span class="fc" id="L187">        sp.set_inactive();</span>

<span class="fc" id="L189">        _stream.save_point_reset_to_prev(sp);</span>

<span class="fc" id="L191">        return;</span>
    }

    private void save_point_clear(SavePoint sp)
    {
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (sp.isClear()) {</span>
<span class="nc" id="L197">            return;</span>
        }
<span class="fc" id="L199">        int start_idx = sp.getStartIdx();</span>
<span class="fc" id="L200">        int end_idx = sp.getEndIdx();</span>
<span class="pc bpc" id="L201" title="1 of 4 branches missed.">        if (end_idx != -1 || start_idx != -1) {</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">            if (start_idx != -1) {</span>
<span class="fc" id="L203">                _open_save_points--;</span>
<span class="fc" id="L204">                save_point_unpin(sp);</span>
            }
        }
<span class="fc" id="L207">    }</span>
    private final void save_point_unpin(SavePoint sp) {
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        if (sp.isActive()) {</span>
<span class="nc" id="L210">            throw new IllegalArgumentException(&quot;you can't release an active save point&quot;);</span>
        }
<span class="pc bpc" id="L212" title="2 of 4 branches missed.">        assert(sp.isDefined());</span>

<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        if (_buffer.decLock()) {</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">            if (_open_save_points == 0) {</span>
<span class="fc" id="L216">                _buffer.resetToCurrentPage();</span>
            }
        }
<span class="fc" id="L219">        return;</span>
    }
    private final SavePoint save_point_start(SavePoint sp, long line_number, long line_start) {
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if (sp.isDefined()) {</span>
<span class="nc" id="L223">            throw new IllegalArgumentException(&quot;you can't start an active save point&quot;);</span>
        }

<span class="fc" id="L226">        int new_pinned_idx = _buffer.getCurrentPageIdx();</span>
<span class="fc" id="L227">        _buffer.incLock();</span>
<span class="fc" id="L228">        sp.set_start_pos(new_pinned_idx,_stream._pos, line_number, line_start);</span>
<span class="fc" id="L229">        _open_save_points++;</span>

<span class="fc" id="L231">        return sp;</span>
    }
    private final void save_point_mark_end(SavePoint sp, int offset) {
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if (sp.isActive()) {</span>
<span class="nc" id="L235">            throw new IllegalArgumentException(&quot;you can't start an active save point&quot;);</span>
        }

<span class="fc" id="L238">        UnifiedDataPageX curr = _buffer.getCurrentPage();</span>
<span class="fc" id="L239">        int curr_idx = _buffer.getCurrentPageIdx();</span>
<span class="fc" id="L240">        int curr_pos = _stream._pos + offset;</span>

        // this adjusts the current page idx and pos (in the page buffer)
        // to handle the end point being offset from the current pos
        // since that may result in the end mark referencing a different page
<span class="fc bfc" id="L245" title="All 2 branches covered.">        if (offset != 0) {</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">            if (curr_pos &gt;= curr.getBufferLimit()) {</span>
<span class="nc" id="L247">                curr_pos -= curr.getOriginalStartingOffset();</span>
<span class="nc" id="L248">                curr_idx++;</span>
<span class="nc" id="L249">                curr = _buffer.getPage(curr_idx);</span>
            }
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            else if (curr_pos &lt; curr.getStartingOffset()) {</span>
<span class="nc" id="L252">                int pos_offset = curr_pos - curr.getOriginalStartingOffset();</span>
<span class="nc" id="L253">                curr_idx--;</span>
<span class="nc" id="L254">                curr = _buffer.getPage(curr_idx);</span>
<span class="nc" id="L255">                curr_pos = curr.getBufferLimit() - pos_offset;</span>
            }
<span class="pc bpc" id="L257" title="3 of 6 branches missed.">            if (curr == null || curr_pos &gt;= curr.getBufferLimit() || curr_pos &lt; curr.getStartingOffset()) {</span>
<span class="nc" id="L258">                end_point_too_far(curr_idx);</span>
            }
        }

<span class="fc" id="L262">        sp.set_end_pos(curr_idx, curr_pos); // we may be &quot;re-setting&quot; the idx (that's ok)</span>

<span class="fc" id="L264">        return;</span>
    }
    private final void end_point_too_far(int curr_idx) {
<span class="nc" id="L267">        String message = &quot;end point [&quot;</span>
                       + curr_idx
                       + &quot;] must be within 1 page of current [&quot;
<span class="nc" id="L270">                       + _buffer.getCurrentPageIdx()</span>
                       + &quot;]&quot;;
<span class="nc" id="L272">        throw new IllegalArgumentException(message);</span>
    }

<span class="pc bpc" id="L275" title="1 of 2 branches missed.">    public static class SavePoint</span>
    {
<span class="fc" id="L277">        public enum SavePointState { CLEAR, DEFINED, ACTIVE }</span>

        private UnifiedSavePointManagerX _owner;
        private SavePointState   _state;
        private int              _start_idx, _start_pos;
        private long             _start_line_count;
        private long             _start_line_start;
        private int              _end_idx, _end_pos;
        private int              _prev_idx, _prev_pos, _prev_limit;
        private long             _prev_line_count;
        private long             _prev_line_start;
        private SavePoint        _next, _prev;
        private SavePoint        _next_active;

<span class="fc" id="L291">        SavePoint(UnifiedSavePointManagerX owner) {</span>
<span class="fc" id="L292">            clear();</span>
<span class="fc" id="L293">            _owner = owner;</span>
<span class="fc" id="L294">        }</span>
        private final void set_start_pos(int idx, int pos, long line_count, long line_start) {
<span class="pc bpc" id="L296" title="2 of 4 branches missed.">            assert(_state == SavePointState.CLEAR);</span>
<span class="fc" id="L297">            _state = SavePointState.DEFINED;</span>
<span class="fc" id="L298">            _start_idx = idx;</span>
<span class="fc" id="L299">            _start_pos = pos;</span>
<span class="fc" id="L300">            _start_line_count = line_count;</span>
<span class="fc" id="L301">            _start_line_start = line_start;</span>
<span class="fc" id="L302">        }</span>
        private final void set_end_pos(int idx, int pos) {
<span class="pc bpc" id="L304" title="2 of 4 branches missed.">            assert(_state == SavePointState.DEFINED);</span>
<span class="fc" id="L305">            _end_idx = idx;</span>
<span class="fc" id="L306">            _end_pos = pos;</span>
<span class="fc" id="L307">        }</span>
        private final void set_prev_pos(int idx, int pos, int limit, long line_count, long line_start) {
<span class="pc bpc" id="L309" title="2 of 4 branches missed.">            assert(_state == SavePointState.DEFINED);</span>
<span class="fc" id="L310">            _prev_idx = idx;</span>
<span class="fc" id="L311">            _prev_pos = pos;</span>
<span class="fc" id="L312">            _prev_limit = limit;</span>
<span class="fc" id="L313">            _prev_line_count = line_count;</span>
<span class="fc" id="L314">            _prev_line_start = line_start;</span>
<span class="fc" id="L315">        }</span>

        public final void clear() {
<span class="pc bpc" id="L318" title="2 of 4 branches missed.">            assert(_state != SavePointState.ACTIVE);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            if (isDefined()) {</span>
<span class="fc" id="L320">                _owner.save_point_clear(this);</span>
            }
<span class="fc" id="L322">            _state = SavePointState.CLEAR;</span>
<span class="fc" id="L323">            _start_idx = -1;</span>
<span class="fc" id="L324">            _end_idx = -1;</span>
<span class="fc" id="L325">            _prev_idx = -1;</span>
<span class="fc" id="L326">        }</span>
        public final void start(long line_number, long line_start) {
<span class="fc" id="L328">            _owner.save_point_start(this, line_number, line_start);</span>
<span class="fc" id="L329">        }</span>
        public final void markEnd() {
<span class="fc" id="L331">            _owner.save_point_mark_end(this, 0);</span>
<span class="fc" id="L332">        }</span>
        public final void markEnd(int offset) {
<span class="fc" id="L334">            _owner.save_point_mark_end(this, offset);</span>
<span class="fc" id="L335">        }</span>
        public final void free() {
<span class="nc" id="L337">            _owner.savePointFree(this);</span>
<span class="nc" id="L338">        }</span>
        public final boolean isClear() {
<span class="fc bfc" id="L340" title="All 2 branches covered.">            return (_state == SavePointState.CLEAR);</span>
        }
        public final boolean isDefined() {
<span class="pc bpc" id="L343" title="1 of 4 branches missed.">            return (_state == SavePointState.DEFINED || _state == SavePointState.ACTIVE);</span>
        }
        public final boolean isActive() {
<span class="fc bfc" id="L346" title="All 2 branches covered.">            return (_state == SavePointState.ACTIVE);</span>
        }
        public final void set_active() {
<span class="pc bpc" id="L349" title="2 of 4 branches missed.">            assert(_state == SavePointState.DEFINED);</span>
<span class="fc" id="L350">            _state = SavePointState.ACTIVE;</span>
<span class="fc" id="L351">        }</span>
        public final void set_inactive() {
<span class="pc bpc" id="L353" title="2 of 4 branches missed.">            assert(_state == SavePointState.ACTIVE);</span>
<span class="fc" id="L354">            _state = SavePointState.DEFINED;</span>
<span class="fc" id="L355">        }</span>
        public final long length() {
<span class="pc bpc" id="L357" title="2 of 4 branches missed.">            if (_start_idx == -1 || _end_idx == -1) {</span>
<span class="nc" id="L358">                return 0;</span>
            }
<span class="fc" id="L360">            return _owner.lengthOf(this);</span>
        }

        public final int getStartIdx() {
<span class="fc" id="L364">            return _start_idx;</span>
        }
        public final int getStartPos() {
<span class="pc bpc" id="L367" title="2 of 4 branches missed.">            assert(_state != SavePointState.CLEAR);</span>
<span class="fc" id="L368">            return _start_pos;</span>
        }
        public final long getStartLineNumber() {
<span class="fc" id="L371">            return _start_line_count;</span>
        }
        public final long getStartLineStart() {
<span class="fc" id="L374">            return _start_line_start;</span>
        }
        public final long getStartFilePosition() {
<span class="nc bnc" id="L377" title="All 2 branches missed.">            if (_start_idx == -1) return -1;</span>
<span class="nc" id="L378">            UnifiedDataPageX p = _owner._buffer.getPage(_start_idx);</span>
<span class="nc" id="L379">            return p.getFilePosition(_start_pos);</span>
        }
        public final int getEndIdx() {
<span class="fc" id="L382">            return _end_idx;</span>
        }
        public final int getEndPos() {
<span class="pc bpc" id="L385" title="2 of 4 branches missed.">            assert(_state != SavePointState.CLEAR);</span>
<span class="fc" id="L386">            return _end_pos;</span>
        }
        public final long getEndFilePosition() {
<span class="nc bnc" id="L389" title="All 4 branches missed.">            assert(_state != SavePointState.CLEAR);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (_end_idx == -1) return -1;</span>
<span class="nc" id="L391">            UnifiedDataPageX p = _owner._buffer.getPage(_end_idx);</span>
<span class="nc" id="L392">            return p.getFilePosition(_end_pos);</span>
        }
        public final int getPrevIdx() {
<span class="fc" id="L395">            return _prev_idx;</span>
        }
        public final int getPrevPos() {
<span class="pc bpc" id="L398" title="2 of 4 branches missed.">            assert(_state != SavePointState.CLEAR);</span>
<span class="fc" id="L399">            return _prev_pos;</span>
        }
        public final int getPrevLimit() {
<span class="pc bpc" id="L402" title="2 of 4 branches missed.">            assert(_state != SavePointState.CLEAR);</span>
<span class="fc" id="L403">            return _prev_limit;</span>
        }
        public final long getPrevLineNumber() {
<span class="fc" id="L406">            return _prev_line_count;</span>
        }
        public final long getPrevLineStart() {
<span class="fc" id="L409">            return _prev_line_start;</span>
        }
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>