<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>_Private_IonConstants.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-javaaaaaaaaaaaaaaa</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">_Private_IonConstants.java</span></div><h1>_Private_IonConstants.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;

import com.amazon.ion.IonException;

/**
 * NOT FOR APPLICATION USE!
 */
<span class="pc bpc" id="L23" title="1 of 2 branches missed.">public final class _Private_IonConstants</span>
{
    private _Private_IonConstants() { }


    public final static int BB_TOKEN_LEN           =    1;

    // 31 bits (java limit) / 7 bits per byte = 5 bytes
    public final static int BB_VAR_INT32_LEN_MAX   =    5;

    // 31 bits (java limit) / 7 bits per byte = 5 bytes
    public final static int BB_VAR_INT64_LEN_MAX   =   10;

    public final static int BB_INT64_LEN_MAX       =    8;
    public final static int BB_VAR_LEN_MIN         =    1;
    public final static int BB_MAX_7BIT_INT        =  127;

    public final static int INT32_SIZE            = 4;

    /** maximum size of textual representation of a {@code long}. */
<span class="fc" id="L43">    public final static int MAX_LONG_TEXT_SIZE    =</span>
<span class="fc" id="L44">        Math.max(Long.toString(Long.MAX_VALUE).length(),</span>
<span class="fc" id="L45">                 Long.toString(Long.MIN_VALUE).length());</span>

    // these are used for various Unicode translation where
    // we need to convert the utf-16 Java characters into
    // unicode scalar values (utf-32 more or less) and back
    public static final int high_surrogate_value = 0xD800;
    public static final int low_surrogate_value = 0xDC00;
    public static final int surrogate_mask = 0xFFFFFC00; // 0x3f &lt;&lt; 10; or the top 6 bits is the marker the low 10 is the 1/2 character
    public static final int surrogate_value_mask = ~0xFFFFFC00; // 0x3f &lt;&lt; 10; or the top 6 bits is the marker the low 10 is the 1/2 character
    public static final int surrogate_utf32_offset = 0x10000;
    public static final int surrogate_utf32_shift = 10;

    // these help convert from Java UTF-16 to Unicode Scalars (aka unicode code
    // points (aka characters)) which are &quot;32&quot; bit values (really just 21 bits)
    // the DON'T check validity of their input, they expect that to have happened
    // already.  This is a perf issue since normally this check has been done
    // to detect that these routines should be called at all - no need to do it
    // twice.
    public static final int makeUnicodeScalar(int high_surrogate, int low_surrogate) {
        int c;
<span class="fc" id="L65">        c = (high_surrogate &amp; surrogate_value_mask) &lt;&lt; surrogate_utf32_shift;</span>
<span class="fc" id="L66">        c |= (low_surrogate &amp; surrogate_value_mask);</span>
<span class="fc" id="L67">        c += surrogate_utf32_offset;</span>
<span class="fc" id="L68">        return c;</span>
    }
    public static final int makeHighSurrogate(int unicodeScalar) {
        int c;
<span class="nc" id="L72">        c = unicodeScalar - surrogate_utf32_offset;</span>
<span class="nc" id="L73">        c &gt;&gt;&gt;= surrogate_utf32_shift;</span>
<span class="nc" id="L74">        c |= high_surrogate_value;</span>
<span class="nc" id="L75">        return c;</span>
    }
    public static final int makeLowSurrogate(int unicodeScalar) {
        int c;
<span class="nc" id="L79">        c = unicodeScalar - surrogate_utf32_offset;</span>
<span class="nc" id="L80">        c &amp;= surrogate_value_mask;</span>
<span class="nc" id="L81">        c |= low_surrogate_value;</span>
<span class="nc" id="L82">        return c;</span>
    }
    public static final boolean isHighSurrogate(int c) {
        boolean is;
<span class="fc bfc" id="L86" title="All 2 branches covered.">        is = (c &amp; surrogate_mask) == high_surrogate_value;</span>
<span class="fc" id="L87">        return is;</span>
    }
    public static final boolean isLowSurrogate(int c) {
        boolean is;
<span class="fc bfc" id="L91" title="All 2 branches covered.">        is = (c &amp; surrogate_mask) == low_surrogate_value;</span>
<span class="fc" id="L92">        return is;</span>
    }
    public static final boolean isSurrogate(int c) {
        boolean is;
<span class="nc bnc" id="L96" title="All 2 branches missed.">        is = (c &amp; (surrogate_mask | (low_surrogate_value - high_surrogate_value))) == high_surrogate_value;</span>
<span class="nc" id="L97">        return is;</span>
    }

    /**
     * The byte sequence indicating use of Ion 1.0 binary format.
     */
<span class="fc" id="L103">    public static final byte[] BINARY_VERSION_MARKER_1_0 = { (byte) 0xE0,</span>
                                                             (byte) 0x01,
                                                             (byte) 0x00,
                                                             (byte) 0xEA };

    /**
     * The number of bytes in {@link #BINARY_VERSION_MARKER_1_0}
     * ({@value #BINARY_VERSION_MARKER_SIZE}).
     */
<span class="fc" id="L112">    public static final int BINARY_VERSION_MARKER_SIZE =</span>
        BINARY_VERSION_MARKER_1_0.length;


    public static final int tidNull         =  0;
    public static final int tidBoolean      =  1;
    public static final int tidPosInt       =  2;
    public static final int tidNegInt       =  3;
    public static final int tidFloat        =  4;
    public static final int tidDecimal      =  5;
    public static final int tidTimestamp    =  6;
    public static final int tidSymbol       =  7;
    public static final int tidString       =  8;
    public static final int tidClob         =  9;
    public static final int tidBlob         = 10; // a
    public static final int tidList         = 11; // b
    public static final int tidSexp         = 12; // c
    public static final int tidStruct       = 13; // d
    public static final int tidTypedecl     = 14; // e
    public static final int tidUnused       = 15; // f

    public static final int tidDATAGRAM     = 16; // not a real type id
    public static final int tidNopPad       = 99; // not a real type id

/* this is just here to help programmer productivity ...
    switch (((td &amp; 0xf0) &gt;&gt; 4)) {
    case IonConstants.tidNull:      // 0
    case IonConstants.tidBoolean:   // 1
    case IonConstants.tidPosInt:    // 2
    case IonConstants.tidNegInt:    // 3
    case IonConstants.tidFloat:     // 4
    case IonConstants.tidDecimal:   // 5
    case IonConstants.tidTimestamp: // 6
    case IonConstants.tidSymbol:    // 7
    case IonConstants.tidString:    // 8
    case IonConstants.tidClob:      // 9
    case IonConstants.tidBlob:      // 10 A
    case IonConstants.tidList:      // 11 B
    case IonConstants.tidSexp:      // 12 C
    case IonConstants.tidStruct:    // 13 D
    case IonConstants.tidTypedecl:  // 14 E
    case IonConstants.tidUnused:    // 15 F
    default:
        throw new IonException(&quot;???&quot;);
    }
*/


<span class="nc" id="L160">    public enum HighNibble {</span>

        //           hnvalue, lengthFollows, isContainer
<span class="nc" id="L163">        hnNull      (tidNull,       false,    false),</span>
<span class="nc" id="L164">        hnBoolean   (tidBoolean,    false,    false),</span>
<span class="nc" id="L165">        hnPosInt    (tidPosInt,     false,    false),</span>
<span class="nc" id="L166">        hnNegInt    (tidNegInt,     false,    false),</span>
<span class="nc" id="L167">        hnFloat     (tidFloat,      false,    false),</span>
<span class="nc" id="L168">        hnDecimal   (tidDecimal,    false,    false),</span>
<span class="nc" id="L169">        hnTimestamp (tidTimestamp,  false,    false),</span>
<span class="nc" id="L170">        hnSymbol    (tidSymbol,     false,    false),</span>
<span class="nc" id="L171">        hnString    (tidString,     false,    false),</span>
<span class="nc" id="L172">        hnClob      (tidClob,       false,    false),</span>
<span class="nc" id="L173">        hnBlob      (tidBlob,       false,    false),</span>
<span class="nc" id="L174">        hnList      (tidList,       true,     true),</span>
<span class="nc" id="L175">        hnSexp      (tidSexp,       true,     true),</span>
<span class="nc" id="L176">        hnStruct    (tidStruct,     true,     true),</span>
<span class="nc" id="L177">        hnTypedecl  (tidTypedecl,   false,    false),</span>
<span class="nc" id="L178">        hnUnused    (tidUnused,     false,    false);</span>

        private int     _value;
        private boolean _lengthFollows;
        private boolean _isContainer;

<span class="nc" id="L184">        HighNibble(int value, boolean lengthFollows, boolean isContainer) {</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">            if ((value &amp; (~0xF)) != 0) {</span>
<span class="nc" id="L186">                throw new IonException(&quot;illegal high nibble initialization&quot;);</span>
            }
<span class="nc" id="L188">            _value = value;</span>
<span class="nc" id="L189">            _lengthFollows = lengthFollows;</span>
<span class="nc" id="L190">            _isContainer = isContainer;</span>
<span class="nc" id="L191">        }</span>
        static public HighNibble getHighNibble(int hn) {
<span class="nc bnc" id="L193" title="All 17 branches missed.">            switch (hn) {</span>
<span class="nc" id="L194">            case tidNull:       return hnNull;</span>
<span class="nc" id="L195">            case tidBoolean:    return hnBoolean;</span>
<span class="nc" id="L196">            case tidPosInt:     return hnPosInt;</span>
<span class="nc" id="L197">            case tidNegInt:     return hnNegInt;</span>
<span class="nc" id="L198">            case tidFloat:      return hnFloat;</span>
<span class="nc" id="L199">            case tidDecimal:    return hnDecimal;</span>
<span class="nc" id="L200">            case tidTimestamp:  return hnTimestamp;</span>
<span class="nc" id="L201">            case tidSymbol:     return hnSymbol;</span>
<span class="nc" id="L202">            case tidString:     return hnString;</span>
<span class="nc" id="L203">            case tidClob:       return hnClob;</span>
<span class="nc" id="L204">            case tidBlob:       return hnBlob;</span>
<span class="nc" id="L205">            case tidList:       return hnList;</span>
<span class="nc" id="L206">            case tidSexp:       return hnSexp;</span>
<span class="nc" id="L207">            case tidStruct:     return hnStruct;</span>
<span class="nc" id="L208">            case tidTypedecl:   return hnTypedecl;</span>
<span class="nc" id="L209">            case tidUnused:     return hnUnused;</span>
            }
<span class="nc" id="L211">            return null;</span>
        }
<span class="nc" id="L213">        public int     value()               { return _value; }</span>
<span class="nc" id="L214">        public boolean lengthAlwaysFollows() { return _lengthFollows; }</span>
<span class="nc" id="L215">        public boolean isContainer()         { return _isContainer; }</span>
    }

    // TODO unify these
    public static final int lnIsNull           = 0x0f;
    public static final int lnIsNullAtom       = lnIsNull;
    public static final int lnIsNullSequence   = lnIsNull;
    public static final int lnIsNullStruct     = lnIsNull;

    public static final int lnIsEmptyContainer = 0x00;
    public static final int lnIsOrderedStruct  = 0x01;
    public static final int lnIsVarLen         = 0x0e;

    public static final int lnBooleanTrue     = 0x01;
    public static final int lnBooleanFalse    = 0x00;
    public static final int lnNumericZero     = 0x00;


    /**
     * Make a type descriptor from two nibbles; all of which are represented as
     * ints.
     *
     * @param highNibble must be a positive int between 0x00 and 0x0F.
     * @param lowNibble must be a positive int between 0x00 and 0x0F.
     *
     * @return the combined nibbles, between 0x00 and 0xFF.
     */
    public static final int makeTypeDescriptor(int highNibble,
                                               int lowNibble)
    {
<span class="pc bpc" id="L245" title="2 of 4 branches missed.">        assert highNibble == (highNibble &amp; 0xF);</span>
<span class="pc bpc" id="L246" title="2 of 4 branches missed.">        assert lowNibble == (lowNibble &amp; 0xF);</span>

<span class="fc" id="L248">        return ((highNibble &lt;&lt; 4) | lowNibble);</span>
    }

    /**
     * Extract the type code (high nibble) from a type descriptor.
     *
     * @param td must be a positive int between 0x00 and 0xFF.
     *
     * @return the high nibble of the input byte, between 0x00 and 0x0F.
     */
    public static final int getTypeCode(int td)
    {
<span class="pc bpc" id="L260" title="3 of 6 branches missed.">        assert td &gt;= 0 &amp;&amp; td &lt;= 0xFF;</span>

<span class="fc" id="L262">        return (td &gt;&gt; 4);</span>
    }

    public static final int getLowNibble(int td)
    {
<span class="fc" id="L267">        return td &amp; 0xf;</span>
    }

<span class="fc" id="L270">    public static final int True =</span>
<span class="fc" id="L271">        makeTypeDescriptor(_Private_IonConstants.tidBoolean,</span>
                           _Private_IonConstants.lnBooleanTrue);

<span class="fc" id="L274">    public static final int False =</span>
<span class="fc" id="L275">        makeTypeDescriptor(_Private_IonConstants.tidBoolean,</span>
                           _Private_IonConstants.lnBooleanFalse);

    /**
     * Prefix string used in IonStructs' equality checks.
     * When a IonValue's field name's text is unknown, this String is prepended
     * to the field name's SID to coerce it to a string to be used as the key.
     * This will eliminate collisions with IonValues with numbers as their
     * field names.
     * &lt;p&gt;
     * For example, these two IonValues (nested in the IonStructs) will have
     * distinct keys:
     *
     * &lt;pre&gt;
     * {&quot;$99&quot;:random_value},
     * {$99:random_value}
     * &lt;/pre&gt;
     *
     * &lt;p&gt;
     * TODO amzn/ion-java/issues/23 However, there is still a potential failure if one of the
     * IonStruct's nested value has a field name with text
     * {@code &quot; -- UNKNOWN SYMBOL TEXT -- $123&quot;}, and that another nested value
     * of an IonStruct has a field name with unknown text and sid 123, these
     * two values will be considered a match within IonStruct's equality checks,
     * which is wrong.
     * &lt;p&gt;
     * See IonAssert for another use of this idiom.
     */
    public static final String UNKNOWN_SYMBOL_TEXT_PREFIX =
        &quot; -- UNKNOWN SYMBOL TEXT -- $&quot;;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>