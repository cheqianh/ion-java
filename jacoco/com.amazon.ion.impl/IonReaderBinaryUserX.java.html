<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonReaderBinaryUserX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">IonReaderBinaryUserX.java</span></div><h1>IonReaderBinaryUserX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;

import com.amazon.ion.IonSystem;
import static com.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;
import static com.amazon.ion.SystemSymbols.ION_1_0_SID;
import static com.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE_SID;

import com.amazon.ion.IonCatalog;
import com.amazon.ion.IonType;
import com.amazon.ion.OffsetSpan;
import com.amazon.ion.RawValueSpanProvider;
import com.amazon.ion.SeekableReader;
import com.amazon.ion.Span;
import com.amazon.ion.SpanProvider;
import com.amazon.ion.SymbolTable;
import com.amazon.ion.SymbolToken;
import com.amazon.ion.UnknownSymbolException;
import com.amazon.ion.impl.UnifiedInputStreamX.FromByteArray;
import com.amazon.ion.impl.UnifiedSavePointManagerX.SavePoint;
import com.amazon.ion.impl._Private_ScalarConversions.AS_TYPE;
import java.io.IOException;
import java.util.Iterator;

<span class="pc bpc" id="L39" title="1 of 2 branches missed.">final class IonReaderBinaryUserX</span>
    extends IonReaderBinarySystemX
    implements _Private_ReaderWriter
{
    /**
     * This is the physical start-of-stream offset when this reader was created.
     * It must be subtracted from the logical offsets exposed by
     * {@link OffsetSpan}s.
     */
    private final int _physical_start_offset;
    private final _Private_LocalSymbolTableFactory _lstFactory;

    IonCatalog  _catalog;

    private static class IonReaderBinarySpan
        extends DowncastingFaceted
        implements Span, OffsetSpan
    {
        private final boolean _isSeekable;

        public IonReaderBinarySpan(boolean isSeekable)
<span class="fc" id="L60">        {</span>
<span class="fc" id="L61">            _isSeekable = isSeekable;</span>
<span class="fc" id="L62">        }</span>

        State       _state;
        long        _offset;
        long        _limit;
        SymbolTable _symbol_table;

        public long getStartOffset()
        {
<span class="fc" id="L71">            return _offset;</span>
        }

        public long getFinishOffset()
        {
<span class="fc" id="L76">            return _limit;</span>
        }

        public boolean isSeekable()
        {
<span class="fc" id="L81">            return _isSeekable;</span>
        }

    }

    public IonReaderBinaryUserX(IonCatalog catalog,
                                _Private_LocalSymbolTableFactory lstFactory,
                                UnifiedInputStreamX userBytes,
                                int physicalStartOffset)
    {
<span class="fc" id="L91">        super(userBytes);</span>
<span class="fc" id="L92">        _physical_start_offset = physicalStartOffset;</span>
<span class="fc" id="L93">        init_user(catalog);</span>
<span class="fc" id="L94">        _lstFactory = lstFactory;</span>
<span class="fc" id="L95">    }</span>

    //FIXME: PERF_TEST was :private
    final void init_user(IonCatalog catalog)
    {
        // TODO check IVM to determine version: amzn/ion-java#19, amzn/ion-java#24
<span class="fc" id="L101">        _symbols = SharedSymbolTable.getSystemSymbolTable(1);</span>
<span class="fc" id="L102">        _catalog = catalog;</span>
<span class="fc" id="L103">    }</span>

    /**
     * Determines the abstract position of the reader, such that one can
     * later {@link #seek} back to it.
     * &lt;p&gt;
     * The current implementation only works when the reader is positioned on
     * a value (not before, between, or after values). In other words, one
     * should only call this method when {@link #getType()} is non-null.
     *
     * @param beforeTid -
     *          When true, the position returned starts before the
     *          type/length octet.
     *          When false, the position returned starts after the
     *          type/length octet and any optional length octets.
     *
     * @return the current position; not null.
     *
     * @throws IllegalStateException if the reader doesn't have a current
     * value.
     */
    public Span getCurrentPosition(boolean beforeTid)
    {
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (getType() == null)</span>
        {
<span class="fc" id="L128">            throw new IllegalStateException(&quot;IonReader isn't positioned on a value&quot;);</span>
        }
        // Only spans that include the TID octet are seekable.
<span class="fc" id="L131">        IonReaderBinarySpan pos = new IonReaderBinarySpan(beforeTid);</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        long start = beforeTid ?  _position_start : _value_start;</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        long len = beforeTid ? _position_len : _value_len;</span>
<span class="fc" id="L134">        pos._offset = start - _physical_start_offset;</span>
<span class="fc" id="L135">        pos._limit = pos._offset + len;</span>
<span class="fc" id="L136">        pos._symbol_table = _symbols;</span>
<span class="fc" id="L137">        pos._state = _state;</span>
<span class="fc" id="L138">        return pos;</span>
    }

    public byte[] getCurrentBuffer()
    {
<span class="fc" id="L143">        return _input._bytes;</span>
    }


    public void seek(IonReaderBinarySpan position)
    {
<span class="fc" id="L149">        IonReaderBinarySpan pos = position;</span>

<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (pos == null)</span>
        {
<span class="nc" id="L153">            throw new IllegalArgumentException(&quot;Position invalid for binary reader&quot;);</span>
        }
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if (!(_input instanceof FromByteArray))</span>
        {
<span class="nc" id="L157">            throw new UnsupportedOperationException(&quot;Binary seek not implemented for non-byte array backed sources&quot;);</span>
        }

        // TODO test that span is within the bounds of the input byte[]

        // manually reset the input specific type of input stream
<span class="fc" id="L163">        FromByteArray input = (FromByteArray)_input;</span>
<span class="fc" id="L164">        input._pos   = (int) (pos._offset + _physical_start_offset);</span>
<span class="fc" id="L165">        input._limit = (int) (pos._limit  + _physical_start_offset);</span>

        // TODO: these (eof and save points) should be put into
        //       a re-init method on the input stream
<span class="fc" id="L169">        input._eof = false;</span>
        for (;;) {
<span class="fc" id="L171">            SavePoint sp = input._save_points._active_stack;</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">            if (sp == null) break;</span>
<span class="nc" id="L173">            input._save_points.savePointPopActive(sp);</span>
<span class="nc" id="L174">            sp.free();</span>
<span class="nc" id="L175">        }</span>

        // reset the raw reader
<span class="fc" id="L178">        re_init_raw();</span>

        // reset the system reader
        // - nothing to do

        // reset the user reader
<span class="fc" id="L184">        init_user(this._catalog);</span>

        // now we need to set our symbol table
<span class="fc" id="L187">        _symbols = pos._symbol_table;</span>

        // and the other misc state variables we had
        // read past before getPosition gets called
        //           Don't do this, we'll re-read the data from the stream.
        //           Otherwise, this reader will be in the wrong state.
        //           For example, getType() will return non-null but that
        //           shouldn't happen until the user calls next().
//        _state         = pos._state;
//        _value_type    = pos._value_type;
//        _value_is_null = pos._value_is_null;
//        _value_is_true = pos._value_is_true;

//        _is_in_struct = false;
<span class="fc" id="L201">    }</span>


    @Override
    public IonType next()
    {
<span class="fc" id="L207">        IonType t = null;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (hasNext()) {</span>
<span class="fc" id="L209">            _has_next_needed = true;</span>
<span class="fc" id="L210">            t = _value_type;</span>
        }
<span class="fc" id="L212">        return t;</span>
    }

    @Override
    public boolean hasNext()
    {
<span class="fc bfc" id="L218" title="All 4 branches covered.">        if (!_eof &amp;&amp; _has_next_needed) {</span>
<span class="fc" id="L219">            clear_system_value_stack();</span>
            try {
<span class="fc bfc" id="L221" title="All 4 branches covered.">                while (!_eof &amp;&amp; _has_next_needed) {</span>
<span class="fc" id="L222">                    has_next_helper_user();</span>
                }
            }
<span class="nc" id="L225">            catch (IOException e) {</span>
<span class="nc" id="L226">                error(e);</span>
<span class="fc" id="L227">            }</span>
        }
<span class="fc bfc" id="L229" title="All 2 branches covered.">        return !_eof;</span>
    }


    private final void has_next_helper_user() throws IOException
    {
<span class="fc" id="L235">        super.hasNext();</span>
<span class="fc bfc" id="L236" title="All 4 branches covered.">        if (getDepth() == 0 &amp;&amp; !_value_is_null) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (_value_tid == _Private_IonConstants.tidSymbol) {</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                if (load_annotations() == 0) {</span>
                    // $ion_1_0 is read as an IVM only if it is not annotated
<span class="fc" id="L240">                    load_cached_value(AS_TYPE.int_value);</span>
<span class="fc" id="L241">                    int sid = _v.getInt();</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">                    if (sid == ION_1_0_SID) {</span>
<span class="fc" id="L243">                        _symbols = SharedSymbolTable.getSystemSymbolTable(1);</span>
<span class="fc" id="L244">                        push_symbol_table(_symbols);</span>
<span class="fc" id="L245">                        _has_next_needed = true;</span>
                    }
<span class="fc" id="L247">                }</span>
            }
<span class="fc bfc" id="L249" title="All 2 branches covered.">            else if (_value_tid == _Private_IonConstants.tidStruct) {</span>
<span class="fc" id="L250">                int count = load_annotations();</span>
<span class="fc bfc" id="L251" title="All 4 branches covered.">                if (count &gt; 0 &amp;&amp; _annotation_ids[0] == ION_SYMBOL_TABLE_SID) {</span>
<span class="fc" id="L252">                    _symbols = _lstFactory.newLocalSymtab(_catalog, this, false);</span>
<span class="fc" id="L253">                    push_symbol_table(_symbols);</span>
<span class="fc" id="L254">                    _has_next_needed = true;</span>
                }
<span class="fc" id="L256">            }</span>
            else {
<span class="pc bpc" id="L258" title="2 of 4 branches missed.">                assert (_value_tid != _Private_IonConstants.tidTypedecl);</span>
            }
        }
<span class="fc" id="L261">    }</span>

    private void validateSymbolToken(SymbolToken symbol) {
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (symbol != null) {</span>
<span class="fc bfc" id="L265" title="All 4 branches covered.">            if (symbol.getText() == null &amp;&amp; symbol.getSid() &gt; getSymbolTable().getMaxId()) {</span>
<span class="fc" id="L266">                throw new UnknownSymbolException(symbol.getSid());</span>
            }
        }
<span class="fc" id="L269">    }</span>

    @Override
    public SymbolToken[] getTypeAnnotationSymbols() {
<span class="fc" id="L273">        SymbolToken[] annotations = super.getTypeAnnotationSymbols();</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        for (SymbolToken annotation : annotations) {</span>
<span class="fc" id="L275">            validateSymbolToken(annotation);</span>
        }
<span class="fc" id="L277">        return annotations;</span>
    }

    @Override
    public final SymbolToken getFieldNameSymbol() {
<span class="fc" id="L282">        SymbolToken fieldName = super.getFieldNameSymbol();</span>
<span class="fc" id="L283">        validateSymbolToken(fieldName);</span>
<span class="fc" id="L284">        return fieldName;</span>
    }

    @Override
    public final SymbolToken symbolValue() {
<span class="fc" id="L289">        SymbolToken symbol = super.symbolValue();</span>
<span class="fc" id="L290">        validateSymbolToken(symbol);</span>
<span class="fc" id="L291">        return symbol;</span>
    }

    //  This code handles the skipped symbol table
    //  support - it is cloned in IonReaderTextUserX,
    //  IonReaderBinaryUserX and _Private_IonWriterBase
    //
    //  SO ANY FIXES HERE WILL BE NEEDED IN THOSE
    //  THREE LOCATIONS AS WELL.
    //
<span class="fc" id="L301">    private int _symbol_table_top = 0;</span>
<span class="fc" id="L302">    private SymbolTable[] _symbol_table_stack = new SymbolTable[3]; // 3 is rare, IVM followed by a local sym tab with open content</span>
    private void clear_system_value_stack()
    {
<span class="fc bfc" id="L305" title="All 2 branches covered.">        while (_symbol_table_top &gt; 0) {</span>
<span class="fc" id="L306">            _symbol_table_top--;</span>
<span class="fc" id="L307">            _symbol_table_stack[_symbol_table_top] = null;</span>
        }
<span class="fc" id="L309">    }</span>
    private void push_symbol_table(SymbolTable symbols)
    {
<span class="pc bpc" id="L312" title="2 of 4 branches missed.">        assert(symbols != null);</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (_symbol_table_top &gt;= _symbol_table_stack.length) {</span>
<span class="nc" id="L314">            int new_len = _symbol_table_stack.length * 2;</span>
<span class="nc" id="L315">            SymbolTable[] temp = new SymbolTable[new_len];</span>
<span class="nc" id="L316">            System.arraycopy(_symbol_table_stack, 0, temp, 0, _symbol_table_stack.length);</span>
<span class="nc" id="L317">            _symbol_table_stack = temp;</span>
        }
<span class="fc" id="L319">        _symbol_table_stack[_symbol_table_top++] = symbols;</span>
<span class="fc" id="L320">    }</span>
    @Override
    public SymbolTable pop_passed_symbol_table()
    {
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (_symbol_table_top &lt;= 0) {</span>
<span class="fc" id="L325">            return null;</span>
        }
<span class="fc" id="L327">        _symbol_table_top--;</span>
<span class="fc" id="L328">        SymbolTable symbols = _symbol_table_stack[_symbol_table_top];</span>
<span class="fc" id="L329">        _symbol_table_stack[_symbol_table_top] = null;</span>
<span class="fc" id="L330">        return symbols;</span>
    }


    //========================================================================
    // Facet support


    @Override
    public &lt;T&gt; T asFacet(Class&lt;T&gt; facetType)
    {
<span class="fc bfc" id="L341" title="All 2 branches covered.">        if (facetType == SpanProvider.class)</span>
        {
<span class="fc" id="L343">            return facetType.cast(new SpanProviderFacet());</span>
        }

        // TODO amzn/ion-java/issues/17 support seeking over InputStream
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (_input instanceof FromByteArray)</span>
        {
<span class="fc bfc" id="L349" title="All 2 branches covered.">            if (facetType == SeekableReader.class)</span>
            {
<span class="fc" id="L351">                return facetType.cast(new SeekableReaderFacet());</span>
            }
<span class="fc bfc" id="L353" title="All 2 branches covered.">            if (facetType == RawValueSpanProvider.class)</span>
            {
<span class="fc" id="L355">                return facetType.cast(new RawValueSpanProviderFacet());</span>
            }
        }

<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (facetType == _Private_ByteTransferReader.class)</span>
        {
            // This is a rather sketchy use of Facets, since the availability
            // of the facet depends upon the current state of this subject,
            // and that can change over time.

            // TODO amzn/ion-java/issues/16 Our {@link #transferCurrentValue} doesn't handle
            //  field names and annotations.

            // Ensure there's a contiguous buffer we can copy.
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">            if (_input instanceof UnifiedInputStreamX.FromByteArray</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">                &amp;&amp; getTypeAnnotationSymbols().length == 0</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">                &amp;&amp; ! isInStruct())</span>
            {
<span class="fc" id="L373">                return facetType.cast(new ByteTransferReaderFacet());</span>
            }
        }

<span class="fc" id="L377">        return super.asFacet(facetType);</span>
    }


<span class="fc" id="L381">    private class SpanProviderFacet implements SpanProvider</span>
    {
        public Span currentSpan()
        {
<span class="fc" id="L385">            return getCurrentPosition(true);</span>
        }
    }

<span class="fc" id="L389">    private class RawValueSpanProviderFacet implements RawValueSpanProvider</span>
    {

        public Span valueSpan()
        {
<span class="fc" id="L394">            return getCurrentPosition(false);</span>
        }

        public byte[] buffer()
        {
<span class="fc" id="L399">            return getCurrentBuffer();</span>
        }

    }

<span class="fc" id="L404">    private class SeekableReaderFacet</span>
        extends SpanProviderFacet
        implements SeekableReader
    {

        public void hoist(Span span)
        {
<span class="fc bfc" id="L411" title="All 4 branches covered.">            if (! (span instanceof IonReaderBinarySpan) || !((IonReaderBinarySpan)span).isSeekable())</span>
            {
<span class="fc" id="L413">                throw new IllegalArgumentException(&quot;Span isn't compatible with this reader.&quot;);</span>
            }

<span class="fc" id="L416">            seek((IonReaderBinarySpan) span);</span>
<span class="fc" id="L417">        }</span>

    }


<span class="fc" id="L422">    private class ByteTransferReaderFacet implements _Private_ByteTransferReader</span>
    {
        public void transferCurrentValue(_Private_ByteTransferSink sink)
            throws IOException
        {
            // Ensure there's a contiguous buffer we can copy.
            // TODO Copy from a stream should also be possible.
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">            if (! (_input instanceof UnifiedInputStreamX.FromByteArray))</span>
            {
<span class="nc" id="L431">                throw new UnsupportedOperationException();</span>
            }

            // TODO amzn/ion-java/issues/16 wrong if current value has a field name or
            //   annotations since the position is in the wrong place.
            // TODO when implementing that, be careful to handle the case where
            //   the writer already holds a pending field name or annotations!
            //   Meaning: the user has set it and then called writeValue().

<span class="fc" id="L440">            int inOffset = (int) _position_start;</span>
<span class="fc" id="L441">            int inLen    = (int) _position_len;</span>

<span class="fc" id="L443">            sink.writeBytes(_input._bytes, inOffset, inLen);</span>
<span class="fc" id="L444">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>