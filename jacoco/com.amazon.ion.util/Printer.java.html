<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Printer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-javaaaaaaaaaaaaaaa</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.util</a> &gt; <span class="el_source">Printer.java</span></div><h1>Printer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.util;

import static com.amazon.ion.SystemSymbols.IMPORTS;
import static com.amazon.ion.SystemSymbols.ION_1_0_SID;
import static com.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE;
import static com.amazon.ion.SystemSymbols.SYMBOLS;

import com.amazon.ion.Decimal;
import com.amazon.ion.IonBlob;
import com.amazon.ion.IonBool;
import com.amazon.ion.IonClob;
import com.amazon.ion.IonDatagram;
import com.amazon.ion.IonDecimal;
import com.amazon.ion.IonFloat;
import com.amazon.ion.IonInt;
import com.amazon.ion.IonList;
import com.amazon.ion.IonNull;
import com.amazon.ion.IonReader;
import com.amazon.ion.IonSequence;
import com.amazon.ion.IonSexp;
import com.amazon.ion.IonString;
import com.amazon.ion.IonStruct;
import com.amazon.ion.IonSymbol;
import com.amazon.ion.IonTimestamp;
import com.amazon.ion.IonType;
import com.amazon.ion.IonValue;
import com.amazon.ion.IonWriter;
import com.amazon.ion.SymbolTable;
import com.amazon.ion.SymbolToken;
import com.amazon.ion.Timestamp;
import com.amazon.ion.impl._Private_IonSymbol;
import com.amazon.ion.impl._Private_IonSystem;
import com.amazon.ion.impl._Private_IonTextWriterBuilder;
import com.amazon.ion.impl._Private_IonValue;
import com.amazon.ion.impl._Private_IonValue.SymbolTableProvider;
import com.amazon.ion.system.IonTextWriterBuilder;
import com.amazon.ion.system.IonTextWriterBuilder.LstMinimizing;
import com.amazon.ion.system.IonWriterBuilder.IvmMinimizing;
import com.amazon.ion.util.IonTextUtils.SymbolVariant;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.util.Iterator;


/**
 * Renders {@link IonValue}s to text.
 * &lt;p&gt;
 * By default, output is in a compact format with minimal whitespace.
 * For example:
 *&lt;pre&gt;
 *    annot::{f1:[&quot;hello&quot;,&quot;goodbye&quot;],'another field':long::0}
 *&lt;/pre&gt;
 * The format can be tuned through various properties on the Printer instance,
 * as well as through the {@link Printer.Options} structure.
 * &lt;p&gt;
 * &lt;b&gt;Instances of this class are safe for use by multiple threads.&lt;/b&gt;
 * &lt;p&gt;
 * While printers are inexpensive to create, their configuration facilities
 * make them useful as shared resources. Changes to configuration settings
 * (&lt;em&gt;e.g.&lt;/em&gt;, {@link #setJsonMode()}) do not affect concurrently-running
 * calls to {@link #print}.
 *
 * @see IonWriter
 * @see IonTextWriterBuilder
 */
public class Printer
{
<span class="fc" id="L84">    public class Options</span>
        implements Cloneable
    {
        public boolean blobAsString;
        public boolean clobAsString;
        public boolean datagramAsList;
        public boolean decimalAsFloat;
        public boolean sexpAsList;
        public boolean skipAnnotations;
        public boolean skipSystemValues;
        public boolean simplifySystemValues;
        public boolean stringAsJson;
        public boolean symbolAsString;
        public boolean timestampAsString;
        public boolean timestampAsMillis;
        public boolean untypedNulls;


        @Override
        public Options clone()
        {
            try
            {
<span class="fc" id="L107">                return (Options) super.clone();</span>
            }
<span class="nc" id="L109">            catch (CloneNotSupportedException e)</span>
            {
<span class="nc" id="L111">                throw new InternalError();</span>
            }
        }
    }


<span class="pc" id="L117">    protected Options myOptions = new Options();</span>

    public Printer()
<span class="fc" id="L120">    {</span>
<span class="fc" id="L121">        myOptions = new Options();</span>
<span class="fc" id="L122">    }</span>

    public Printer(Options options)
<span class="nc" id="L125">    {</span>
<span class="nc" id="L126">        myOptions = options.clone();</span>
<span class="nc" id="L127">    }</span>


    //=========================================================================
    // Options

    /* Potential printing options:
     *
     * - Render all times with a specific offset (what about unknowns?)
     * - Render all times with long offset (no Z)
     * - control over decimal-point placement in float and decimal.
     *   (render 12.00 or 1200d-2)
     */


    /**
     * Indicates whether this printer skips (&lt;em&gt;i.e.&lt;/em&gt;, doesn't print)
     * system IDs and local symbol tables.
     * By default, this property is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized boolean getSkipSystemValues()
    {
<span class="nc" id="L149">        return myOptions.skipSystemValues;</span>
    }

    /**
     * Sets whether this printer skips (&lt;em&gt;i.e.&lt;/em&gt;, doesn't print)
     * system IDs and local symbol tables.
     * By default, this property is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized void setSkipSystemValues(boolean skip)
    {
<span class="fc" id="L159">        myOptions.skipSystemValues = skip;</span>
<span class="fc" id="L160">    }</span>


    /**
     * Indicates whether this printer skips (&lt;em&gt;i.e.&lt;/em&gt;, doesn't print)
     * annotations.
     * By default, this property is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized boolean getSkipAnnotations()
    {
<span class="nc" id="L170">        return myOptions.skipAnnotations;</span>
    }

    /**
     * Sets whether this printer skips (&lt;em&gt;i.e.&lt;/em&gt;, doesn't print)
     * annotations.
     * By default, this property is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized void setSkipAnnotations(boolean skip)
    {
<span class="fc" id="L180">        myOptions.skipAnnotations = skip;</span>
<span class="fc" id="L181">    }</span>


    /**
     * Indicates whether this printer renders blobs as Base64 strings.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized boolean getPrintBlobAsString()
    {
<span class="nc" id="L190">        return myOptions.blobAsString;</span>
    }

    /**
     * Sets whether this printer renders blobs as Base64 strings.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized void setPrintBlobAsString(boolean blobAsString)
    {
<span class="fc" id="L199">        myOptions.blobAsString = blobAsString;</span>
<span class="fc" id="L200">    }</span>


    /**
     * Indicates whether this printer renders clobs as ASCII strings.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized boolean getPrintClobAsString()
    {
<span class="nc" id="L209">        return myOptions.clobAsString;</span>
    }

    /**
     * Sets whether this printer renders clobs as ASCII strings.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized void setPrintClobAsString(boolean clobAsString)
    {
<span class="fc" id="L218">        myOptions.clobAsString = clobAsString;</span>
<span class="fc" id="L219">    }</span>


    /**
     * Indicates whether this printer renders datagrams as lists.
     * By default, this property is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized boolean getPrintDatagramAsList()
    {
<span class="nc" id="L228">        return myOptions.datagramAsList;</span>
    }

    /**
     * Sets whether this printer renders datagrams as lists.
     * By default, this property is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized void setPrintDatagramAsList(boolean datagramAsList)
    {
<span class="fc" id="L237">        myOptions.datagramAsList = datagramAsList;</span>
<span class="fc" id="L238">    }</span>


    /**
     * Indicates whether this printer renders decimals as floats, thus using 'e'
     * notation for all real values.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized boolean getPrintDecimalAsFloat()
    {
<span class="nc" id="L248">        return myOptions.decimalAsFloat;</span>
    }

    /**
     * Sets whether this printer renders decimals as floats, thus using 'e'
     * notation for all real values.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized void setPrintDecimalAsFloat(boolean decimalAsFloat)
    {
<span class="fc" id="L258">        myOptions.decimalAsFloat = decimalAsFloat;</span>
<span class="fc" id="L259">    }</span>


    /**
     * Indicates whether this printer renders sexps as lists.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized boolean getPrintSexpAsList()
    {
<span class="nc" id="L268">        return myOptions.sexpAsList;</span>
    }

    /**
     * Sets whether this printer renders sexps as lists.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized void setPrintSexpAsList(boolean sexpAsList)
    {
<span class="fc" id="L277">        myOptions.sexpAsList = sexpAsList;</span>
<span class="fc" id="L278">    }</span>


    /**
     * Indicates whether this printer renders strings using JSON escapes.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized boolean getPrintStringAsJson()
    {
<span class="nc" id="L287">        return myOptions.stringAsJson;</span>
    }

    /**
     * Sets whether this printer renders strings using JSON escapes.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized void setPrintStringAsJson(boolean stringAsJson)
    {
<span class="fc" id="L296">        myOptions.stringAsJson = stringAsJson;</span>
<span class="fc" id="L297">    }</span>


    /**
     * Indicates whether this printer renders symbols as strings.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized boolean getPrintSymbolAsString()
    {
<span class="nc" id="L306">        return myOptions.symbolAsString;</span>
    }

    /**
     * Sets whether this printer renders symbols as strings.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized void setPrintSymbolAsString(boolean symbolAsString)
    {
<span class="fc" id="L315">        myOptions.symbolAsString = symbolAsString;</span>
<span class="fc" id="L316">    }</span>


    /**
     * Indicates whether this printer renders timestamps as millisecond values.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized boolean getPrintTimestampAsMillis()
    {
<span class="nc" id="L325">        return myOptions.timestampAsMillis;</span>
    }

    /**
     * Sets whether this printer renders timestamps as millisecond values.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized void setPrintTimestampAsMillis(boolean timestampAsMillis)
    {
<span class="nc" id="L334">        myOptions.timestampAsMillis = timestampAsMillis;</span>
<span class="nc" id="L335">    }</span>


    /**
     * Indicates whether this printer renders timestamps as strings.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized boolean getPrintTimestampAsString()
    {
<span class="nc" id="L344">        return myOptions.timestampAsString;</span>
    }

    /**
     * Sets whether this printer renders timestamps as strings.
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized void setPrintTimestampAsString(boolean timestampAsString)
    {
<span class="fc" id="L353">        myOptions.timestampAsString = timestampAsString;</span>
<span class="fc" id="L354">    }</span>


    /**
     * Indicates whether this printer renders all null values as {@code null}
     * (&lt;em&gt;i.e.&lt;/em&gt;, the same as an {@link IonNull}).
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized boolean getPrintUntypedNulls()
    {
<span class="nc" id="L364">        return myOptions.untypedNulls;</span>
    }

    /**
     * Sets whether this printer renders all null values as {@code null}
     * (&lt;em&gt;i.e.&lt;/em&gt;, the same as an {@link IonNull}).
     * By default, this is &lt;code&gt;false&lt;/code&gt;.
     */
    public synchronized void setPrintUntypedNulls(boolean untypedNulls)
    {
<span class="nc" id="L374">        myOptions.untypedNulls = untypedNulls;</span>
<span class="nc" id="L375">    }</span>


    /**
     * Configures this printer's options to render legal JSON text.
     * The following options are modified so that:
     * &lt;ul&gt;
     *   &lt;li&gt;{@link Options#blobAsString} is {@code true}&lt;/li&gt;
     *   &lt;li&gt;{@link Options#clobAsString} is {@code true}&lt;/li&gt;
     *   &lt;li&gt;{@link Options#datagramAsList} is {@code true}&lt;/li&gt;
     *   &lt;li&gt;{@link Options#decimalAsFloat} is {@code true}&lt;/li&gt;
     *   &lt;li&gt;{@link Options#sexpAsList} is {@code true}&lt;/li&gt;
     *   &lt;li&gt;{@link Options#skipAnnotations} is {@code true}&lt;/li&gt;
     *   &lt;li&gt;{@link Options#skipSystemValues} is {@code true}&lt;/li&gt;
     *   &lt;li&gt;{@link Options#stringAsJson} is {@code true}&lt;/li&gt;
     *   &lt;li&gt;{@link Options#symbolAsString} is {@code true}&lt;/li&gt;
     *   &lt;li&gt;{@link Options#timestampAsString} is {@code false}&lt;/li&gt;
     *   &lt;li&gt;{@link Options#timestampAsMillis} is {@code true}&lt;/li&gt;
     *   &lt;li&gt;{@link Options#untypedNulls} is {@code true}&lt;/li&gt;
     * &lt;/ul&gt;
     * All other options are left as is.
     */
    public synchronized void setJsonMode()
    {
<span class="fc" id="L399">        myOptions.blobAsString      = true;</span>
<span class="fc" id="L400">        myOptions.clobAsString      = true;</span>
<span class="fc" id="L401">        myOptions.datagramAsList    = true;</span>
<span class="fc" id="L402">        myOptions.decimalAsFloat    = true;</span>
<span class="fc" id="L403">        myOptions.sexpAsList        = true;</span>
<span class="fc" id="L404">        myOptions.skipAnnotations   = true;</span>
<span class="fc" id="L405">        myOptions.skipSystemValues  = true;</span>
<span class="fc" id="L406">        myOptions.stringAsJson      = true;</span>
<span class="fc" id="L407">        myOptions.symbolAsString    = true;</span>
<span class="fc" id="L408">        myOptions.timestampAsString = false;</span>
<span class="fc" id="L409">        myOptions.timestampAsMillis = true;</span>
<span class="fc" id="L410">        myOptions.untypedNulls      = true;</span>
<span class="fc" id="L411">    }</span>


    //=========================================================================
    // Print methods


    public void print(IonValue value, Appendable out)
        throws IOException
    {
        // Copy the options so visitor won't see changes made while printing.
        Options options;
<span class="fc" id="L423">        synchronized (this)  // So we don't clone in the midst of changes</span>
        {
<span class="fc" id="L425">            options = myOptions.clone();</span>
<span class="fc" id="L426">        }</span>

        if (true)
        {
<span class="fc" id="L430">            _print(value, makeVisitor(options, out));</span>
        }
        else
        {
            // Bridge to the configurable text writer. This is here for
            // testing purposes. It *almost* works except for printing
            // datagram as list.

            boolean dg = value instanceof IonDatagram;

            _Private_IonTextWriterBuilder o =
                _Private_IonTextWriterBuilder.standard();
            o.setCharset(IonTextWriterBuilder.ASCII);
            if (dg)
            {
                if (options.skipSystemValues)
                {
                    o.withMinimalSystemData();
                }
                else if (options.simplifySystemValues) {

                    o.setIvmMinimizing(IvmMinimizing.DISTANT);
                    o.setLstMinimizing(LstMinimizing.LOCALS);
                }
            }

            o._blob_as_string      = options.blobAsString;
            o._clob_as_string      = options.clobAsString;
            o._decimal_as_float    = options.decimalAsFloat;
            // TODO datagram as list
            o._sexp_as_list        = options.sexpAsList;
            o._skip_annotations    = options.skipAnnotations;
            o._string_as_json      = options.stringAsJson;
            o._symbol_as_string    = options.symbolAsString;
            o._timestamp_as_millis = options.timestampAsMillis;
            o._timestamp_as_string = options.timestampAsString;
            o._untyped_nulls       = options.untypedNulls;

            IonWriter writer = o.build(out);
            // TODO doesn't work for datagram since it skips system values
            // value.writeTo(writer);
            _Private_IonSystem system = (_Private_IonSystem) value.getSystem();
            IonReader reader = system.newSystemReader(value);
            writer.writeValues(reader);
            writer.finish();
        }
<span class="fc" id="L476">    }</span>

    private void _print(IonValue value, PrinterVisitor pv)
        throws IOException
    {
        try
        {
<span class="fc bfc" id="L483" title="All 2 branches covered.">            if (! (value instanceof IonDatagram))</span>
            {
<span class="fc" id="L485">                pv.setSymbolTableProvider(new BasicSymbolTableProvider(value.getSymbolTable()));</span>
            }
<span class="fc" id="L487">            value.accept(pv);</span>
        }
<span class="nc" id="L489">        catch (IOException e)</span>
        {
<span class="nc" id="L491">            throw e;</span>
        }
<span class="fc" id="L493">        catch (RuntimeException e)</span>
        {
<span class="fc" id="L495">            throw e;</span>
        }
<span class="nc" id="L497">        catch (Exception e)</span>
        {
            // Shouldn't happen.
<span class="nc" id="L500">            throw new RuntimeException(e);</span>
<span class="fc" id="L501">        }</span>
<span class="fc" id="L502">    }</span>


    /**
     * Subclasses can override this if they wish to construct a specialization
     * of the {@link PrinterVisitor}.
     *
     * @param options is a fresh copy of the Printer's options instance,
     * not &lt;code&gt;null&lt;/code&gt;.
     * @param out is not &lt;code&gt;null&lt;/code&gt;.
     * @return the visitor to invoke for printing.
     */
    protected PrinterVisitor makeVisitor(Options options, Appendable out)
    {
<span class="fc" id="L516">        return new PrinterVisitor(options, out);</span>
    }


    private static class BasicSymbolTableProvider
        implements SymbolTableProvider
    {
        private final SymbolTable symbolTable;

        public BasicSymbolTableProvider(SymbolTable symbolTable)
<span class="fc" id="L526">        {</span>
<span class="fc" id="L527">            this.symbolTable = symbolTable;</span>
<span class="fc" id="L528">        }</span>

        public SymbolTable getSymbolTable()
        {
<span class="fc" id="L532">            return symbolTable;</span>
        }

    }

    //=========================================================================
    // Print methods

    public static class PrinterVisitor
        extends AbstractValueVisitor
    {

        final protected Options    myOptions;
        final protected Appendable myOut;

        /**
         * Should we quote operators at the current level of the hierarchy?
         * As we recurse down into containers, this value is pushed on the
         * stack by {@link #writeChild(IonValue, boolean)}.
         */
<span class="fc" id="L552">        private boolean    myQuoteOperators = true;</span>

<span class="fc" id="L554">        private SymbolTableProvider mySymbolTableProvider = null;</span>


        //---------------------------------------------------------------------

        public PrinterVisitor(Options options, Appendable out)
<span class="fc" id="L560">        {</span>
<span class="fc" id="L561">            myOptions = options;</span>
<span class="fc" id="L562">            myOut = out;</span>
<span class="fc" id="L563">        }</span>

        void setSymbolTableProvider(SymbolTableProvider symbolTableProvider)
        {
<span class="fc" id="L567">            mySymbolTableProvider = symbolTableProvider;</span>
<span class="fc" id="L568">        }</span>

        /**
         * Recurse down into a container, we push the current value of
         * {@link #myQuoteOperators} onto the stack and replace it with
         * the given value.
         *
         * @param value
         * @param quoteOperators replaces the current value of
         * {@link #myQuoteOperators} during the recursive visitation.
         * @throws Exception propagated from visitation of &lt;code&gt;value&lt;/code&gt;.
         * @throws NullPointerException if &lt;code&gt;value&lt;/code&gt; is null.
         */
        protected void writeChild(IonValue value, boolean quoteOperators)
            throws Exception
        {
<span class="fc" id="L584">            boolean oldQuoteOperators = myQuoteOperators;</span>
<span class="fc" id="L585">            myQuoteOperators = quoteOperators;</span>
<span class="fc" id="L586">            value.accept(this);</span>
<span class="fc" id="L587">            myQuoteOperators = oldQuoteOperators;</span>
<span class="fc" id="L588">        }</span>


        public void writeAnnotations(IonValue value) throws IOException
        {
<span class="fc bfc" id="L593" title="All 2 branches covered.">            if (! myOptions.skipAnnotations)</span>
            {
<span class="fc" id="L595">                SymbolToken[] anns = ((_Private_IonValue)value).getTypeAnnotationSymbols(mySymbolTableProvider);</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">                if (anns != null)</span>
                {
<span class="fc bfc" id="L598" title="All 2 branches covered.">                    for (SymbolToken ann : anns) {</span>
<span class="fc" id="L599">                        String text = ann.getText();</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">                        if (text == null) {</span>
<span class="fc" id="L601">                            myOut.append('$');</span>
<span class="fc" id="L602">                            myOut.append(Integer.toString(ann.getSid()));</span>
                        }
                        else {
<span class="fc" id="L605">                            IonTextUtils.printSymbol(myOut, text);</span>
                        }
<span class="fc" id="L607">                        myOut.append(&quot;::&quot;);</span>
                    }
                }
            }
<span class="fc" id="L611">        }</span>

        public void writeNull(String type) throws IOException
        {
<span class="fc bfc" id="L615" title="All 2 branches covered.">            if (myOptions.untypedNulls)</span>
            {
<span class="fc" id="L617">                myOut.append(&quot;null&quot;);</span>
            }
            else
            {
<span class="fc" id="L621">                myOut.append(&quot;null.&quot;);</span>
<span class="fc" id="L622">                myOut.append(type);</span>
            }
<span class="fc" id="L624">        }</span>


        public void writeSequenceContent(IonSequence value,
                                         boolean quoteOperators,
                                         char open,
                                         char separator,
                                         char close)
            throws IOException, Exception
        {
<span class="fc" id="L634">            myOut.append(open);</span>

<span class="fc" id="L636">            boolean hitOne = false;</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">            for (IonValue child : value)</span>
            {
<span class="fc bfc" id="L639" title="All 2 branches covered.">                if (hitOne)</span>
                {
<span class="fc" id="L641">                    myOut.append(separator);</span>
                }
<span class="fc" id="L643">                hitOne = true;</span>

<span class="fc" id="L645">                writeChild(child, quoteOperators);</span>
<span class="fc" id="L646">            }</span>

<span class="fc" id="L648">            myOut.append(close);</span>
<span class="fc" id="L649">        }</span>

        public void writeSymbolToken(SymbolToken sym) throws IOException
        {
<span class="fc" id="L653">            String text = sym.getText();</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">            if (text != null)</span>
            {
<span class="fc" id="L656">                writeSymbol(text);</span>
            }
            else
            {
<span class="fc" id="L660">                int sid = sym.getSid();</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">                if (sid &lt; 0)</span>
                {
<span class="nc" id="L663">                    throw new IllegalArgumentException(&quot;Bad SID &quot; + sid);</span>
                }

<span class="fc" id="L666">                text = &quot;$&quot; + sym.getSid();</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">                if (myOptions.symbolAsString)</span>
                {
<span class="fc" id="L669">                    writeString(text);</span>
                }
                else
                {
<span class="fc" id="L673">                    myOut.append(text);  // SID literal is never quoted</span>
                }
            }
<span class="fc" id="L676">        }</span>

        public void writeSymbol(String text) throws IOException
        {
<span class="fc bfc" id="L680" title="All 2 branches covered.">            if (myOptions.symbolAsString)</span>
            {
<span class="fc" id="L682">                writeString(text);</span>
            }
            else
            {
<span class="fc" id="L686">                SymbolVariant variant = IonTextUtils.symbolVariant(text);</span>
<span class="pc bpc" id="L687" title="1 of 4 branches missed.">                switch (variant)</span>
                {
                    case IDENTIFIER:
<span class="fc" id="L690">                        myOut.append(text);</span>
<span class="fc" id="L691">                        break;</span>
                    case OPERATOR:
<span class="fc bfc" id="L693" title="All 2 branches covered.">                        if (! myQuoteOperators)</span>
                        {
<span class="fc" id="L695">                            myOut.append(text);</span>
<span class="fc" id="L696">                            break;</span>
                        }
                        // else fall through...
                    case QUOTED:
<span class="fc" id="L700">                        IonTextUtils.printQuotedSymbol(myOut, text);</span>
                        break;
                }
            }
<span class="fc" id="L704">        }</span>


        /**
         * @param text may be null
         */
        public void writeString(String text) throws IOException
        {
<span class="fc bfc" id="L712" title="All 2 branches covered.">            if (myOptions.stringAsJson)</span>
            {
<span class="fc" id="L714">                IonTextUtils.printJsonString(myOut, text);</span>
            }
            else
            {
<span class="fc" id="L718">                IonTextUtils.printString(myOut, text);</span>
            }
<span class="fc" id="L720">        }</span>


        //---------------------------------------------------------------------
        // AbstractValueVisitor overrides

        @Override
        protected void defaultVisit(IonValue value)
        {
<span class="nc" id="L729">            String message = &quot;cannot print &quot; + value.getClass().getName();</span>
<span class="nc" id="L730">            throw new UnsupportedOperationException(message);</span>
        }

        @Override
        public void visit(IonBlob value) throws IOException
        {
<span class="fc" id="L736">            writeAnnotations(value);</span>

<span class="fc bfc" id="L738" title="All 2 branches covered.">            if (value.isNullValue())</span>
            {
<span class="fc" id="L740">                writeNull(&quot;blob&quot;);</span>
            }
            else
            {
<span class="fc bfc" id="L744" title="All 2 branches covered.">                myOut.append(myOptions.blobAsString ? &quot;\&quot;&quot; : &quot;{{&quot;);</span>
<span class="fc" id="L745">                value.printBase64(myOut);</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">                myOut.append(myOptions.blobAsString ? &quot;\&quot;&quot; : &quot;}}&quot;);</span>
            }
<span class="fc" id="L748">        }</span>

        @Override
        public void visit(IonBool value)
            throws IOException
        {
<span class="fc" id="L754">            writeAnnotations(value);</span>

<span class="fc bfc" id="L756" title="All 2 branches covered.">            if (value.isNullValue())</span>
            {
<span class="fc" id="L758">                writeNull(&quot;bool&quot;);</span>
            }
            else
            {
<span class="fc bfc" id="L762" title="All 2 branches covered.">                myOut.append(value.booleanValue() ? &quot;true&quot; : &quot;false&quot;);</span>
            }
<span class="fc" id="L764">        }</span>

        @Override
        public void visit(IonClob value) throws IOException
        {
<span class="fc" id="L769">            writeAnnotations(value);</span>

<span class="fc bfc" id="L771" title="All 2 branches covered.">            if (value.isNullValue())</span>
            {
<span class="fc" id="L773">                writeNull(&quot;clob&quot;);</span>
            }
            else
            {
<span class="fc bfc" id="L777" title="All 2 branches covered.">                if (! myOptions.clobAsString)</span>
                {
<span class="fc" id="L779">                    myOut.append(&quot;{{&quot;);</span>
                }
<span class="fc" id="L781">                myOut.append('&quot;');</span>

<span class="fc" id="L783">                InputStream byteStream = value.newInputStream();</span>
                try
                {
                    int c;
                    // if-statement hoisted above loop for efficiency
<span class="fc bfc" id="L788" title="All 2 branches covered.">                    if (myOptions.stringAsJson)</span>
                    {
<span class="fc bfc" id="L790" title="All 2 branches covered.">                        while ((c = byteStream.read()) != -1)</span>
                        {
<span class="fc" id="L792">                            IonTextUtils.printJsonCodePoint(myOut, c);</span>
                        }
                    }
                    else
                    {
<span class="fc bfc" id="L797" title="All 2 branches covered.">                        while ((c = byteStream.read()) != -1)</span>
                        {
<span class="fc" id="L799">                            IonTextUtils.printStringCodePoint(myOut, c);</span>
                        }
                    }
                }
                finally
                {
<span class="fc" id="L805">                    byteStream.close();</span>
                }

<span class="fc" id="L808">                myOut.append('&quot;');</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">                if (! myOptions.clobAsString)</span>
                {
<span class="fc" id="L811">                    myOut.append(&quot;}}&quot;);</span>
                }
            }
<span class="fc" id="L814">        }</span>

        @Override
        public void visit(IonDatagram value) throws IOException, Exception
        {
<span class="fc bfc" id="L819" title="All 2 branches covered.">            Iterator&lt;IonValue&gt; i = (myOptions.skipSystemValues</span>
<span class="fc" id="L820">                                       ? value.iterator()</span>
<span class="fc" id="L821">                                       : value.systemIterator());</span>

<span class="fc" id="L823">            final boolean asList = myOptions.datagramAsList;</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">            if (asList)</span>
            {
<span class="fc" id="L826">                myOut.append('[');</span>
            }

<span class="fc" id="L829">            boolean hitOne = false;</span>

            // If we're skipping system values at the iterator level,
            // we don't need to bother trying to simplify them.
<span class="pc bpc" id="L833" title="1 of 4 branches missed.">            final boolean simplify_system_values =</span>
                myOptions.simplifySystemValues &amp;&amp; ! myOptions.skipSystemValues;

<span class="fc" id="L836">            SymbolTable previous_symbols = null;</span>

<span class="fc bfc" id="L838" title="All 2 branches covered.">            while (i.hasNext())</span>
            {
<span class="fc" id="L840">                IonValue child = i.next();</span>
<span class="fc" id="L841">                SymbolTable childSymbolTable = child.getSymbolTable();</span>
<span class="fc" id="L842">                mySymbolTableProvider = new BasicSymbolTableProvider(childSymbolTable); //children of datagrams are top-level values</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">                if (simplify_system_values)</span>
                {
<span class="fc" id="L845">                    child = simplify(child, previous_symbols);</span>
<span class="fc" id="L846">                    previous_symbols = childSymbolTable;</span>
                }

<span class="fc bfc" id="L849" title="All 2 branches covered.">                if (child != null)</span>
                {
<span class="fc bfc" id="L851" title="All 2 branches covered.">                    if (hitOne)</span>
                    {
<span class="fc bfc" id="L853" title="All 2 branches covered.">                        myOut.append(asList  ?  ','  :  ' ');</span>
                    }
<span class="fc" id="L855">                    writeChild(child, true);</span>
<span class="fc" id="L856">                    hitOne = true; // we've only &quot;hit one&quot; if we wrote it</span>
                }
<span class="fc" id="L858">            }</span>

<span class="fc bfc" id="L860" title="All 2 branches covered.">            if (asList)</span>
            {
<span class="fc" id="L862">                myOut.append(']');</span>
            }
<span class="fc" id="L864">        }</span>

        private final IonValue simplify(IonValue child,
                                        SymbolTable previous_symbols)
        {
<span class="fc" id="L869">            IonType t = child.getType();</span>
<span class="pc bpc" id="L870" title="1 of 3 branches missed.">            switch (t) {</span>
            case STRUCT:
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">                if (child.hasTypeAnnotation(ION_SYMBOL_TABLE)) {</span>
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">                    if (symbol_table_struct_has_imports(child))</span>
                    {
<span class="nc" id="L875">                        return ((IonStruct)child).cloneAndRemove(SYMBOLS);</span>
                    }
<span class="fc" id="L877">                    return null;</span>
                }
                // fall through to default (print the value)
                break;
            case SYMBOL:
<span class="fc bfc" id="L882" title="All 2 branches covered.">                if (((IonSymbol)child).getSymbolId() == ION_1_0_SID) {</span>
<span class="pc bpc" id="L883" title="3 of 4 branches missed.">                    if (previous_symbols != null &amp;&amp; previous_symbols.isSystemTable()) {</span>
<span class="nc" id="L884">                        return null;</span>
                    }
                    // fall through to default (print the value)
                }
                // fall through to default (print the value)
                break;
            default:
                break;
            }
<span class="fc" id="L893">            return child;</span>
        }

        static final private boolean symbol_table_struct_has_imports(IonValue child) {
<span class="fc" id="L897">            IonStruct struct = (IonStruct)child;</span>
<span class="fc" id="L898">            IonValue imports = struct.get(IMPORTS);</span>
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">            if (imports instanceof IonList) {</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">                return ((IonList)imports).size() != 0;</span>
            }
<span class="fc" id="L902">            return false;</span>
        }

        @Override
        public void visit(IonDecimal value) throws IOException
        {
<span class="fc" id="L908">            writeAnnotations(value);</span>

<span class="fc bfc" id="L910" title="All 2 branches covered.">            if (value.isNullValue())</span>
            {
<span class="fc" id="L912">                writeNull(&quot;decimal&quot;);</span>
            }
            else
            {
<span class="fc" id="L916">                Decimal decimal = value.decimalValue();</span>
<span class="fc" id="L917">                BigInteger unscaled = decimal.unscaledValue();</span>

<span class="fc" id="L919">                int signum = decimal.signum();</span>
<span class="fc bfc" id="L920" title="All 2 branches covered.">                if (signum &lt; 0)</span>
                {
<span class="fc" id="L922">                    myOut.append('-');</span>
<span class="fc" id="L923">                    unscaled = unscaled.negate();</span>
                }
<span class="fc bfc" id="L925" title="All 4 branches covered.">                else if (signum == 0 &amp;&amp; decimal.isNegativeZero())</span>
                {
                    // for the various forms of negative zero we have to
                    // write the sign ourselves, since neither BigInteger
                    // nor BigDecimal recognize negative zero, but Ion does.
<span class="fc" id="L930">                    myOut.append('-');</span>
                }


<span class="fc" id="L934">                final String unscaledText = unscaled.toString();</span>
<span class="fc" id="L935">                final int significantDigits = unscaledText.length();</span>

<span class="fc" id="L937">                final int scale = decimal.scale();</span>
<span class="fc" id="L938">                final int exponent = -scale;</span>

<span class="fc bfc" id="L940" title="All 2 branches covered.">                if (myOptions.decimalAsFloat)</span>
                {
<span class="fc" id="L942">                    myOut.append(unscaledText);</span>
<span class="fc" id="L943">                    myOut.append('e');</span>
<span class="fc" id="L944">                    myOut.append(Integer.toString(exponent));</span>
                }
<span class="fc bfc" id="L946" title="All 2 branches covered.">                else if (exponent == 0)</span>
                {
<span class="fc" id="L948">                    myOut.append(unscaledText);</span>
<span class="fc" id="L949">                    myOut.append('.');</span>
                }
<span class="fc bfc" id="L951" title="All 2 branches covered.">                else if (0 &lt; scale)</span>
                {
                    int wholeDigits;
                    int remainingScale;
<span class="fc bfc" id="L955" title="All 2 branches covered.">                    if (significantDigits &gt; scale)</span>
                    {
<span class="fc" id="L957">                        wholeDigits = significantDigits - scale;</span>
<span class="fc" id="L958">                        remainingScale = 0;</span>
                    }
                    else
                    {
<span class="fc" id="L962">                        wholeDigits = 1;</span>
<span class="fc" id="L963">                        remainingScale = scale - significantDigits + 1;</span>
                    }

<span class="fc" id="L966">                    myOut.append(unscaledText, 0, wholeDigits);</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">                    if (wholeDigits &lt; significantDigits)</span>
                    {
<span class="fc" id="L969">                        myOut.append('.');</span>
<span class="fc" id="L970">                        myOut.append(unscaledText, wholeDigits,</span>
                                     significantDigits);
                    }

<span class="fc bfc" id="L974" title="All 2 branches covered.">                    if (remainingScale != 0)</span>
                    {
<span class="fc" id="L976">                        myOut.append(&quot;d-&quot;);</span>
<span class="fc" id="L977">                        myOut.append(Integer.toString(remainingScale));</span>
                    }
<span class="fc" id="L979">                }</span>
                else // (exponent &gt; 0)
                {
                    // We cannot move the decimal point to the right, adding
                    // rightmost zeros, because that would alter the precision.
<span class="fc" id="L984">                    myOut.append(unscaledText);</span>
<span class="fc" id="L985">                    myOut.append('d');</span>
<span class="fc" id="L986">                    myOut.append(Integer.toString(exponent));</span>
                }
            }
<span class="fc" id="L989">        }</span>

        @Override
        public void visit(IonFloat value) throws IOException
        {
<span class="fc" id="L994">            writeAnnotations(value);</span>

<span class="fc bfc" id="L996" title="All 2 branches covered.">            if (value.isNullValue())</span>
            {
<span class="fc" id="L998">                writeNull(&quot;float&quot;);</span>
            }
            else
            {
<span class="fc" id="L1002">                double real = value.doubleValue();</span>
<span class="fc" id="L1003">                IonTextUtils.printFloat(myOut, real);</span>
            }
<span class="fc" id="L1005">        }</span>

        @Override
        public void visit(IonInt value) throws IOException
        {
<span class="fc" id="L1010">            writeAnnotations(value);</span>

<span class="fc bfc" id="L1012" title="All 2 branches covered.">            if (value.isNullValue())</span>
            {
<span class="fc" id="L1014">                writeNull(&quot;int&quot;);</span>
            }
            else
            {
<span class="fc" id="L1018">                myOut.append(value.bigIntegerValue().toString(10));</span>
            }
<span class="fc" id="L1020">        }</span>

        @Override
        public void visit(IonList value) throws IOException, Exception
        {
<span class="fc" id="L1025">            writeAnnotations(value);</span>

<span class="fc bfc" id="L1027" title="All 2 branches covered.">            if (value.isNullValue())</span>
            {
<span class="fc" id="L1029">                writeNull(&quot;list&quot;);</span>
            }
            else
            {
<span class="fc" id="L1033">                writeSequenceContent(value, true, '[', ',', ']');</span>
            }
<span class="fc" id="L1035">        }</span>

        @Override
        public void visit(IonNull value) throws IOException
        {
<span class="fc" id="L1040">            writeAnnotations(value);</span>
<span class="fc" id="L1041">            myOut.append(&quot;null&quot;);</span>
<span class="fc" id="L1042">        }</span>


        @Override
        public void visit(IonSexp value) throws IOException, Exception
        {
<span class="fc" id="L1048">            writeAnnotations(value);</span>

<span class="fc bfc" id="L1050" title="All 2 branches covered.">            if (value.isNullValue())</span>
            {
<span class="fc" id="L1052">                writeNull(&quot;sexp&quot;);</span>
            }
<span class="fc bfc" id="L1054" title="All 2 branches covered.">            else if (myOptions.sexpAsList)</span>
            {
<span class="fc" id="L1056">                writeSequenceContent(value, true, '[', ',', ']');</span>
            }
            else
            {
<span class="fc" id="L1060">                writeSequenceContent(value, false, '(', ' ', ')');</span>
            }
<span class="fc" id="L1062">        }</span>


        @Override
        public void visit(IonString value) throws IOException
        {
<span class="fc" id="L1068">            writeAnnotations(value);</span>

<span class="fc bfc" id="L1070" title="All 2 branches covered.">            if (value.isNullValue())</span>
            {
<span class="fc" id="L1072">                writeNull(&quot;string&quot;);</span>
            }
            else
            {
<span class="fc" id="L1076">                writeString(value.stringValue());</span>
            }
<span class="fc" id="L1078">        }</span>


        @Override
        public void visit(IonStruct value) throws IOException, Exception
        {
<span class="fc" id="L1084">            writeAnnotations(value);</span>

<span class="fc bfc" id="L1086" title="All 2 branches covered.">            if (value.isNullValue())</span>
            {
<span class="fc" id="L1088">                writeNull(&quot;struct&quot;);</span>
            }
            else
            {
<span class="fc" id="L1092">                myOut.append('{');</span>

<span class="fc" id="L1094">                boolean hitOne = false;</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">                for (IonValue child : value)</span>
                {
<span class="fc bfc" id="L1097" title="All 2 branches covered.">                    if (hitOne)</span>
                    {
<span class="fc" id="L1099">                        myOut.append(',');</span>
                    }
<span class="fc" id="L1101">                    hitOne = true;</span>

<span class="fc" id="L1103">                    SymbolToken sym = ((_Private_IonValue)child).getFieldNameSymbol(mySymbolTableProvider);</span>
<span class="fc" id="L1104">                    writeSymbolToken(sym);</span>
<span class="fc" id="L1105">                    myOut.append(':');</span>
<span class="fc" id="L1106">                    writeChild(child, true);</span>
<span class="fc" id="L1107">                }</span>
<span class="fc" id="L1108">                myOut.append('}');</span>
            }
<span class="fc" id="L1110">        }</span>


        @Override
        public void visit(IonSymbol value) throws IOException
        {
<span class="fc" id="L1116">            writeAnnotations(value);</span>

<span class="fc" id="L1118">            SymbolToken is = ((_Private_IonSymbol)value).symbolValue(mySymbolTableProvider);</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">            if (is == null)</span>
            {
<span class="fc" id="L1121">                writeNull(&quot;symbol&quot;);</span>
            }
            else
            {
<span class="fc" id="L1125">                writeSymbolToken(is);</span>
            }
<span class="fc" id="L1127">        }</span>


        @Override
        public void visit(IonTimestamp value) throws IOException
        {
<span class="fc" id="L1133">            writeAnnotations(value);</span>

<span class="fc bfc" id="L1135" title="All 2 branches covered.">            if (value.isNullValue())</span>
            {
<span class="fc" id="L1137">                writeNull(&quot;timestamp&quot;);</span>
            }
<span class="fc bfc" id="L1139" title="All 2 branches covered.">            else if (myOptions.timestampAsMillis)</span>
            {
<span class="fc" id="L1141">                myOut.append(Long.toString(value.getMillis()));</span>
            }
            else
            {
<span class="fc" id="L1145">                Timestamp ts = value.timestampValue();</span>

<span class="fc bfc" id="L1147" title="All 2 branches covered.">                if (myOptions.timestampAsString)</span>
                {
<span class="fc" id="L1149">                    myOut.append('&quot;');</span>
<span class="fc" id="L1150">                    ts.print(myOut);</span>
<span class="fc" id="L1151">                    myOut.append('&quot;');</span>
                }
                else
                {
<span class="fc" id="L1155">                    ts.print(myOut);</span>
                }
            }
<span class="fc" id="L1158">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>